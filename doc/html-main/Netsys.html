<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netstring_pcre.html">
<link rel="next" href="Netsys_posix.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Uq_mt" rel="Chapter" href="Uq_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Equeue_howto" rel="Chapter" href="Equeue_howto.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netunichar" rel="Chapter" href="Netunichar.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netsys_sem" rel="Chapter" href="Netsys_sem.html">
<link title="Netsys_pmanage" rel="Chapter" href="Netsys_pmanage.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Generic file descriptors" rel="Section" href="#1_Genericfiledescriptors">
<link title="Functions for sockets" rel="Section" href="#1_Functionsforsockets">
<link title="Helper functions" rel="Section" href="#1_Helperfunctions">
<link title="IP addresses" rel="Section" href="#1_IPaddresses">
<link title="Multicast Functions" rel="Section" href="#1_MulticastFunctions">
<link title="Profiling" rel="Section" href="#1_Profiling">
<link title="Deprecated" rel="Section" href="#1_Deprecated">
<link title="Further Documentation" rel="Section" href="#1_FurtherDocumentation">
<link title="Debugging" rel="Section" href="#1_Debugging">
<link title="How to orderly close I/O channels" rel="Subsection" href="#2_HowtoorderlycloseIOchannels">
<title>Ocamlnet 3 Reference Manual : Netsys</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Netstring_pcre.html" title="Netstring_pcre">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Netsys_posix.html" title="Netsys_posix">Next</a>
</div>
<h1>Module <a href="type_Netsys.html">Netsys</a></h1>
<pre><span class="keyword">module</span> Netsys: <code class="code">sig</code> <a href="Netsys.html">..</a> <code class="code">end</code></pre><div class="info">
System calls missing in the <code class="code">Unix</code> module<br>
</div>
<hr width="100%">
<br>
<h1 id="1_Genericfiledescriptors">Generic file descriptors</h1><br>
<br>
Not all OS provide generic read/write functions, or some emulation
    layer does not allow to use a descriptor with read/write. In the
    following functions, the style of the descriptor can be passed along
    with the descriptor to select the right I/O method. Effectively,
    the <code class="code">fd_style</code> indicates which I/O function to call. Sometimes it is
    mandatory to call this function, sometimes it is only a good advice
    because the function provides the best interface for the kind of
    descriptor.<br>
<pre><span id="TYPEfd_style"><span class="keyword">type</span> <code class="type"></code>fd_style</span> = <code class="type">[ `Read_write<br>       | `Recv_send of Unix.sockaddr * Unix.sockaddr<br>       | `Recv_send_implied<br>       | `Recvfrom_sendto<br>       | `W32_event<br>       | `W32_input_thread<br>       | `W32_output_thread<br>       | `W32_pipe<br>       | `W32_pipe_server<br>       | `W32_process ]</code> </pre>
<div class="info">
Some information what kind of operations are reasonable for descriptors:<ul>
<li><code class="code">`Read_write</code>: The descriptor is neither a socket not one of the
        other special cases, so only read/write is possible if read/write
        is possible at all. This style is also used if it is meaningless
        to use data I/O like read/write at all.</li>
<li><code class="code">`Recv_send(sockaddr,peeraddr)</code>: The descriptor is a connected socket.
        recv/send are the preferred operations.</li>
<li><code class="code">`Recvfrom_sendto</code>: The descriptor is an unconnected socket, and
        it is possible to ask for addresses when exchanging data, so 
        recvfrom/sendto are the preferred operations.</li>
<li><code class="code">`Recv_send_implied</code>: The descriptor is a socket with implied 
        connection. There are no socket addresses.
        recv/send are the preferred operations. It is not possible to call
        <code class="code">getsockname</code> or <code class="code">getpeername</code>.</li>
<li><code class="code">`W32_pipe</code>: The descriptor is a proxy descriptor for a Win32 named
        pipe as returned by <a href="Netsys_win32.html#VALpipe_descr"><code class="code">Netsys_win32.pipe_descr</code></a>. </li>
<li><code class="code">`W32_pipe_server</code>: The descriptor is a proxy descriptor for a Win32
        pipe server as returned by
        <a href="Netsys_win32.html#VALpipe_server_descr"><code class="code">Netsys_win32.pipe_server_descr</code></a>. </li>
<li><code class="code">`W32_event</code>: The descriptor is a Win32 proxy descriptor for an event
         as returned by <a href="Netsys_win32.html#VALcreate_event"><code class="code">Netsys_win32.create_event</code></a>. It is not possible to
        read/write with these descriptors.</li>
<li><code class="code">`W32_process</code>: The descriptor is a proxy descriptor for a Win32
        process as returned by
        <a href="Netsys_win32.html#VALcreate_process"><code class="code">Netsys_win32.create_process</code></a>. It is not possible to read/write
        with these descriptors.</li>
<li><code class="code">`W32_input_thread</code>: The descriptor is a proxy descriptor for a
        Win32-specific input thread
        as returned by
        <a href="Netsys_win32.html#VALcreate_input_thread"><code class="code">Netsys_win32.create_input_thread</code></a>. </li>
<li><code class="code">`W32_output_thread</code>: The descriptor is a proxy descriptor for a
        Win32-specific output thread
        as returned by
        <a href="Netsys_win32.html#VALcreate_output_thread"><code class="code">Netsys_win32.create_output_thread</code></a>. </li>
</ul>

      Win32: For the exact meaning of proxy descriptors, please see 
      <a href="Netsys_win32.html"><code class="code">Netsys_win32</code></a>. In short, a proxy descriptor is an abstract handle
      for the I/O object. The handle itself cannot be used for I/O, however,
      but only some specialized function. The proxy descriptor can only
      be used to dereference the I/O object. Note that the following functions
      like <code class="code">gread</code> and <code class="code">gwrite</code> automatically look up the I/O object behind
      the proxy and call the right I/O function.<br>
</div>

<pre><span id="VALget_fd_style"><span class="keyword">val</span> get_fd_style</span> : <code class="type">Unix.file_descr -> <a href="Netsys.html#TYPEfd_style">fd_style</a></code></pre><div class="info">
Get the file descriptor style<br>
</div>
<pre><span id="VALgread"><span class="keyword">val</span> gread</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> string -> int -> int -> int</code></pre><div class="info">
<code class="code">gread fd_style fd s pos len</code>: Reads up to <code class="code">len</code> bytes from 
      descriptor <code class="code">fd</code> which is supposed to support the I/O style 
      <code class="code">fd_style</code>, i.e. the right system call (<code class="code">read</code>, <code class="code">recv</code>,
      <code class="code">recvfrom</code>) is chosen to read from the descriptor.
       After <code class="code">n &lt;= len</code> bytes have been read these are put into
      string <code class="code">s</code> at positions <code class="code">pos</code> to <code class="code">pos+n-1</code>, and <code class="code">n</code> is returned.
      The function can fail with any I/O exception defined for the
      actually performed I/O operation. Whether the operation is blocking
      or non-blocking depends on the descriptor.
<p>

      If <code class="code">len&gt;0</code> but <code class="code">n=0</code> the end of the input data is reached.<br>
</div>
<pre><span id="VALblocking_gread"><span class="keyword">val</span> blocking_gread</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> string -> int -> int -> int</code></pre><div class="info">
<code class="code">let p = blocking_gread fd_style fd s pos len</code>: 
      Like <code class="code">gread</code> up to <code class="code">len</code> bytes are read from <code class="code">fd</code> and stored in <code class="code">s</code>.
      If the I/O operation is blocking but the descriptor is in 
      non-blocking mode, this function blocks until the operation can
      be performed. If the operation is interrupted by a signal it is
      automatically restarted.
<p>

      If <code class="code">n &lt; len</code> the end of the input data is reached (where <code class="code">n</code> is the
      returned number).
<p>

      See <code class="code">wait_until_readable</code> below for further information which
      types of descriptors can be handled in non-blocking mode.<br>
</div>
<pre><span id="VALreally_gread"><span class="keyword">val</span> really_gread</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> string -> int -> int -> unit</code></pre><div class="info">
<code class="code">really_read fd_style fd s pos len</code>: Reads exactly <code class="code">len</code> bytes from <code class="code">fd</code>
      and stores them in <code class="code">s</code> starting at <code class="code">pos</code>. If the end of file condition
      is seen before <code class="code">len</code> bytes are read, the exception <code class="code">End_of_file</code>
      is raised, and it is unspecified how many bytes have been stored in
      <code class="code">s</code>. Like <code class="code">blocking_gread</code>, non-blocking descriptors are forced
      to block until the operation becomes possible, and interruptions by
      signals are handled.
<p>

      See <code class="code">wait_until_readable</code> below for further information which
      types of descriptors can be handled in non-blocking mode.<br>
</div>
<pre><span id="VALgwrite"><span class="keyword">val</span> gwrite</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> string -> int -> int -> int</code></pre><div class="info">
<code class="code">gwrite fd_style fd s pos len</code>: Writes up to <code class="code">len</code> bytes to
      descriptor <code class="code">fd</code> which is supposed to support the I/O style 
      <code class="code">fd_style</code>, i.e. the right system call (<code class="code">write</code>, <code class="code">send</code>,
      <code class="code">sendto</code>) is chosen to write to the descriptor.
    . The <code class="code">n &lt;= len</code> written bytes are taken from string <code class="code">s</code>,
      starting at position <code class="code">pos</code> until <code class="code">pos+n-1</code>. The number <code class="code">n</code> is
      returned. The function can fail with any I/O exception defined for the
      actually performed I/O operation. Whether the operation is blocking
      or non-blocking depends on the descriptor.<br>
</div>
<pre><span id="VALreally_gwrite"><span class="keyword">val</span> really_gwrite</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> string -> int -> int -> unit</code></pre><div class="info">
<code class="code">really_write fd_style fd s pos len</code>: Writes exactly the <code class="code">len</code> bytes
      from <code class="code">s</code> to <code class="code">fd</code> starting at <code class="code">pos</code>. 
      If the I/O operation is blocking but the descriptor is in 
      non-blocking mode, this function blocks until the operation can
      be performed. If the operation is interrupted by a signal it is
      automatically restarted.
<p>

      See <code class="code">wait_until_writable</code> below for further information which
      types of descriptors can be handled in non-blocking mode.<br>
</div>
<pre><span id="EXCEPTIONShutdown_not_supported"><span class="keyword">exception</span> Shutdown_not_supported</span></pre>
<div class="info">
See <code class="code">gshutdown</code><br>
</div>
<pre><span id="VALgshutdown"><span class="keyword">val</span> gshutdown</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> Unix.shutdown_command -> unit</code></pre><div class="info">
<code class="code">gshutdown fd_style fd cmd</code>: If there is the possibility to shut down
      the connection for this kind of descriptor, the shutdown is tried.
      It is possible that the function raises the <code class="code">EAGAIN</code> Unix error if
      the shutdown operation is non-blocking, and currently not possible. 
      It is suggested to wait until the descriptor is writable, and to try
      again then.
<p>

      If there is no shutdown operation for this kind of descriptor, the
      exception <code class="code">Shutdown_not_supported</code> is raised. In this case it is
      usually sufficient to close the descriptor (<code class="code">gclose</code>, see below),
      and when all descriptors to the resource are closed, the resource
      is shut down by the OS.
<p>

      Details by <code class="code">fd_style</code>:<ul>
<li><code class="code">`Recv_send</code> and <code class="code">`Recv_send_implied</code>: The socket is shut
         down as requested by <code class="code">Unix.shutdown</code>. This only triggers the
         shutdown, but does not wait until it is completed. Also,
         errors are usually not immediately reported.</li>
<li><code class="code">`W32_pipe</code>: It is only possible to request <code class="code">SHUTDOWN_ALL</code>
         for these descriptors.  For other shutdown types, the error
         <code class="code">EPERM</code> is reported. The shutdown is synchronous and completed
         when the function returns.</li>
<li><code class="code">`W32_pipe_server</code>: It is only possible to request <code class="code">SHUTDOWN_ALL</code>
         for these descriptors.  For other shutdown types, the error
         <code class="code">EPERM</code> is reported. A shutdown means here to stop accepting
         new connections. The shutdown is synchronous and completed
         when the function returns.</li>
<li><code class="code">`W32_output_thread</code>:  It is only possible to request <code class="code">SHUTDOWN_SEND</code>
         for these descriptors. A <code class="code">SHUTDOWN_ALL</code> is also interpreted as
         <code class="code">SHUTDOWN_SEND</code>, and a <code class="code">SHUTDOWN_RECEIVE</code> is ignored.
         A shutdown means here that the EOF is appended
         to the output buffer, and when the output thread has written the
         buffer contents, the underlying descriptor (not <code class="code">fd</code>!) will be
         closed. The shutdown operation is non-blocking. If it is not
         possible at the moment of calling, the error <code class="code">EAGAIN</code> is reported.</li>
<li>Other styles raise <code class="code">Shutdown_not_supported</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALis_readable"><span class="keyword">val</span> is_readable</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> bool</code></pre><pre><span id="VALis_writable"><span class="keyword">val</span> is_writable</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> bool</code></pre><pre><span id="VALis_prird"><span class="keyword">val</span> is_prird</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> bool</code></pre><div class="info">
Test whether the descriptor would not block if one of the input,
      output, or priority input operations were done.
<p>

      On POSIX systems the tests work for a wide variety of descriptor 
      types (but not for regular files which are assumed to be always
      readable and writable).
      If the <code class="code">poll</code> interface is available it is preferred over the
      <code class="code">select</code> interface to conduct the test.
<p>

      On Win32, the tests are limited to sockets, named pipes and
      event objects. (The latter two only in the form provided by
      <a href="Netsys_win32.html"><code class="code">Netsys_win32</code></a>, see there.)
<p>

      Generally, if the blocking status cannot be determined for
      a class of I/O operations, the functions return <code class="code">true</code>, in
      the hope that it is better to block than to never conduct
      the operation.<br>
</div>
<pre><span id="VALwait_until_readable"><span class="keyword">val</span> wait_until_readable</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> float -> bool</code></pre><pre><span id="VALwait_until_writable"><span class="keyword">val</span> wait_until_writable</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> float -> bool</code></pre><pre><span id="VALwait_until_prird"><span class="keyword">val</span> wait_until_prird</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> float -> bool</code></pre><div class="info">
Wait until an operation for a single descriptor becomes possible.
      The float argument is the timeout (negative value means no timeout).
      Returns whether the operation is possible (<code class="code">true</code>). Otherwise,
      there was a timeout (<code class="code">false</code>).
<p>

      On POSIX systems this works for a wide variety of descriptor 
      types (but not for regular files which are assumed to be always
      readable and writable).
      If the <code class="code">poll</code> interface is available it is preferred over the
      <code class="code">select</code> interface to wait for I/O. The functions also catch
      interruptions by signals.
<p>

      On Win32, waiting is limited to sockets, named pipes and
      event objects. (The latter two only in the form provided by
      <a href="Netsys_win32.html"><code class="code">Netsys_win32</code></a>, see there.)
<p>

      Generally, if waiting is not supported for
      a class of I/O operations, the functions return immediately <code class="code">true</code>, in
      the hope that it is better to block than to never conduct
      the operation.<br>
</div>
<pre><span id="VALgclose"><span class="keyword">val</span> gclose</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> Unix.file_descr -> unit</code></pre><div class="info">
Shuts down the system object referenced by the descriptor so far
      possible, and closes the descriptor.
<p>

      Errors are logged to <a href="Netlog.html"><code class="code">Netlog</code></a> as <code class="code">`Crit</code> events, and
      do not generate exceptions.
<p>

      The exact semantics of the close operation varies from descriptor
      style to descriptor style. Generally, <code class="code">gclose</code> assumes that all
      I/O is done, and all buffers are flushed, and that one can tear
      down the underlying communication circuits. <code class="code">gclose</code> is always
      the right choice when the I/O channel needs to be aborted after a
      fatal error, and it does not matter whether errors occur or not.
      If a data connection needs to be orderly closed (i.e. without
      data loss), one should first try to finish the communication,
      either by protocol means (e.g. wait for ACK messages), or by
      calling <code class="code">gshutdown</code> first (see above).<br>
</div>
<br>
<h1 id="1_Functionsforsockets">Functions for sockets</h1><br>
<pre><span id="VALwait_until_connected"><span class="keyword">val</span> wait_until_connected</span> : <code class="type">Unix.file_descr -> float -> bool</code></pre><div class="info">
After a non-blocking connect has been initiated, this function can be
      used to wait until (1) the connect is successful, or (2) the connect
      fails, or (3) the operation times out. The <code class="code">float</code> argument is the
      timeout value (negative value means no timeout).
      The function returns <code class="code">true</code> for the cases (1) and (2), and <code class="code">false</code>
      for case (3). The cases (1) and (2) can be further analyzed by
      calling <code class="code">connect_check</code> (see below).
<p>

      On POSIX, this function is identical to <code class="code">wait_until_writable</code>. On
      Win32 the wait condition is slightly different.
<p>

      On Win32, this function also tolerates client proxy descriptors for
      Win32 named pipes. However, there is no waiting - the function 
      immediately returns.<br>
</div>
<pre><span id="VALconnect_check"><span class="keyword">val</span> connect_check</span> : <code class="type">Unix.file_descr -> unit</code></pre><div class="info">
Tests whether the socket is connected with the peer after calling
      <code class="code">Unix.connect</code>. If the socket is connected, the function returns normally.
      Otherwise, the current socket error is raised as a <code class="code">Unix.Unix_error</code>
      exception. This function is intended to be called after a 
      non-blocking connect has been initiated, and the success or error
      is indicated (e.g. after <code class="code">wait_until_connected</code> returns).
<p>

      Side effect: The per-socket error code may be reset.
<p>

      On Win32, this function also tolerates client proxy descriptors for
      Win32 named pipes. However, there is no real check - the function 
      immediately returns.<br>
</div>
<pre><span id="VALdomain_of_inet_addr"><span class="keyword">val</span> domain_of_inet_addr</span> : <code class="type">Unix.inet_addr -> Unix.socket_domain</code></pre><div class="info">
Returns the socket domain of Internet addresses, i.e. whether the
 address is IPv4 or IPv6<br>
</div>
<pre><span id="VALprotostring_of_inet_addr"><span class="keyword">val</span> protostring_of_inet_addr</span> : <code class="type">Unix.inet_addr -> string</code></pre><pre><span id="VALinet_addr_of_protostring"><span class="keyword">val</span> inet_addr_of_protostring</span> : <code class="type">string -> Unix.inet_addr</code></pre><div class="info">
Converts an IP address to the 4 bytes (IPv4) or 16 bytes (IPv6)
      representation in network byte order, and vice-versa<br>
</div>
<pre><span id="VALgetpeername"><span class="keyword">val</span> getpeername</span> : <code class="type">Unix.file_descr -> Unix.sockaddr</code></pre><div class="info">
like <code class="code">Unix.getpeername</code>, but errors are fixed up. <code class="code">ENOTCONN</code> is
      ensured when the socked is unconnected or shut down.<br>
</div>
<br>
<h1 id="1_Helperfunctions">Helper functions</h1><br>
<pre><span id="VALis_absolute"><span class="keyword">val</span> is_absolute</span> : <code class="type">string -> bool</code></pre><div class="info">
Whether this file path is absolute. Works for Unix and Win32.<br>
</div>
<pre><span id="VALrestart"><span class="keyword">val</span> restart</span> : <code class="type">('a -> 'b) -> 'a -> 'b</code></pre><div class="info">
<code class="code">restart f arg</code> calls <code class="code">f arg</code>, and restarts this call if the
 exception <code class="code">Unix_error(EINTR,_,_)</code> is caught.
<p>

 Note that there are some cases where this handling of <code class="code">EINTR</code> is
 not sufficient:<ul>
<li>Functions that have a timeout argument like <code class="code">Unix.select</code>: When
   <code class="code">EINTR</code> is caught the timeout should be adjusted.</li>
<li><code class="code">Unix.connect</code> with a blocking descriptor because this is not
   well-enough specified by POSIX</li>
</ul>
<br>
</div>
<pre><span id="VALrestart_tmo"><span class="keyword">val</span> restart_tmo</span> : <code class="type">(float -> 'b) -> float -> 'b</code></pre><div class="info">
<code class="code">restart_tmo f tmo</code> calls <code class="code">f</code> with a timeout argument <code class="code">tmo</code>, and
 restarted the call if the exception <code class="code">Unix_error(EINTR,_,_)</code> is caught.
 In the restart case, the timeout argument is reduced by the
 already elapsed time.
<p>

 Negative timeout arguments are interpreted as "no timeout".<br>
</div>
<pre><span id="VALrestarting_select"><span class="keyword">val</span> restarting_select</span> : <code class="type">Unix.file_descr list -><br>       Unix.file_descr list -><br>       Unix.file_descr list -><br>       float -> Unix.file_descr list * Unix.file_descr list * Unix.file_descr list</code></pre><div class="info">
A wrapper around <code class="code">Unix.select</code> that handles the <code class="code">EINTR</code> condition.
<p>

      Note: This function calls <code class="code">Unix.select</code> and shares all pros and cons
      with <code class="code">Unix.select</code>. In particular, the OS often sets a limit on the 
      number (and/or the numeric value) of the descriptors (e.g. for
      Linux it is 1024, for Windows it is 64). On Ocaml 3.11 the Windows
      version of <code class="code">Unix.select</code> includes some support for other types
      of descriptors than sockets.<br>
</div>
<pre><span id="VALsleep"><span class="keyword">val</span> sleep</span> : <code class="type">float -> unit</code></pre><pre><span id="VALrestarting_sleep"><span class="keyword">val</span> restarting_sleep</span> : <code class="type">float -> unit</code></pre><div class="info">
Sleep for the passed time. <code class="code">restarting_sleep</code> additionally handles
      <code class="code">EINTR</code>.<br>
</div>
<pre><span id="VALunix_error_of_code"><span class="keyword">val</span> unix_error_of_code</span> : <code class="type">int -> Unix.error</code></pre><div class="info">
Converts an integer error into the corresponding variant<br>
</div>
<pre><span id="VALint64_of_file_descr"><span class="keyword">val</span> int64_of_file_descr</span> : <code class="type">Unix.file_descr -> int64</code></pre><div class="info">
Returns the file descriptor as int64 number. Works for all OS.<br>
</div>
<pre><span id="VALstring_of_fd"><span class="keyword">val</span> string_of_fd</span> : <code class="type">Unix.file_descr -> string</code></pre><div class="info">
Return a string describing the descriptor (for debugging)<br>
</div>
<pre><span id="VALstring_of_sockaddr"><span class="keyword">val</span> string_of_sockaddr</span> : <code class="type">Unix.sockaddr -> string</code></pre><div class="info">
Returns a human-readable string describing the address
      (for debug messages)
<p>

      Note that the reverse (parsing such a string) can be
      accomplished with <a href="Netsockaddr.html#VALsocksymbol_of_string"><code class="code">Netsockaddr.socksymbol_of_string</code></a> and
      <a href="Uq_resolver.html#VALsockaddr_of_socksymbol"><code class="code">Uq_resolver.sockaddr_of_socksymbol</code></a>.<br>
</div>
<pre><span id="VALstring_of_fd_style"><span class="keyword">val</span> string_of_fd_style</span> : <code class="type"><a href="Netsys.html#TYPEfd_style">fd_style</a> -> string</code></pre><div class="info">
Returns a string describing the fd style (debugging)<br>
</div>
<pre><span id="VALis_stdin"><span class="keyword">val</span> is_stdin</span> : <code class="type">Unix.file_descr -> bool</code></pre><pre><span id="VALis_stdout"><span class="keyword">val</span> is_stdout</span> : <code class="type">Unix.file_descr -> bool</code></pre><pre><span id="VALis_stderr"><span class="keyword">val</span> is_stderr</span> : <code class="type">Unix.file_descr -> bool</code></pre><div class="info">
Returns whether the descriptors are stdin/stdout/stderr<br>
</div>
<pre><span id="VALset_close_on_exec"><span class="keyword">val</span> set_close_on_exec</span> : <code class="type">Unix.file_descr -> unit</code></pre><pre><span id="VALclear_close_on_exec"><span class="keyword">val</span> clear_close_on_exec</span> : <code class="type">Unix.file_descr -> unit</code></pre><div class="info">
Working versions of the functions with the same name in <code class="code">Unix</code><br>
</div>
<pre><span id="VAL_exit"><span class="keyword">val</span> _exit</span> : <code class="type">int -> unit</code></pre><div class="info">
Exit the program immediately without running the atexit handlers.
 The argument is the exit code, just as for <code class="code">exit</code>.<br>
</div>
<br>
<h1 id="1_IPaddresses">IP addresses</h1><br>
<pre><span id="VALlogand_inet_addr"><span class="keyword">val</span> logand_inet_addr</span> : <code class="type">Unix.inet_addr -> Unix.inet_addr -> Unix.inet_addr</code></pre><div class="info">
Returns the bitwise AND of the two argument addresses<br>
</div>
<pre><span id="VALlogor_inet_addr"><span class="keyword">val</span> logor_inet_addr</span> : <code class="type">Unix.inet_addr -> Unix.inet_addr -> Unix.inet_addr</code></pre><div class="info">
Returns the bitwise OR of the two argument addresses<br>
</div>
<pre><span id="VALlogxor_inet_addr"><span class="keyword">val</span> logxor_inet_addr</span> : <code class="type">Unix.inet_addr -> Unix.inet_addr -> Unix.inet_addr</code></pre><div class="info">
Returns the bitwise XOR of the two argument addresses<br>
</div>
<pre><span id="VALlognot_inet_addr"><span class="keyword">val</span> lognot_inet_addr</span> : <code class="type">Unix.inet_addr -> Unix.inet_addr</code></pre><div class="info">
Returns the bitwise NOT of the argument address<br>
</div>
<pre><span id="VALis_ipv4_inet_addr"><span class="keyword">val</span> is_ipv4_inet_addr</span> : <code class="type">Unix.inet_addr -> bool</code></pre><div class="info">
Whether the address is an IPv4 address<br>
</div>
<pre><span id="VALis_ipv6_inet_addr"><span class="keyword">val</span> is_ipv6_inet_addr</span> : <code class="type">Unix.inet_addr -> bool</code></pre><div class="info">
Whether the address is an IPv6 address<br>
</div>
<pre><span id="VALis_multicast_inet_addr"><span class="keyword">val</span> is_multicast_inet_addr</span> : <code class="type">Unix.inet_addr -> bool</code></pre><div class="info">
Whether the address is a multicast address (either IPv4 or IPv6)<br>
</div>
<br>
<h1 id="1_MulticastFunctions">Multicast Functions</h1><br>
<pre><span id="VALmcast_set_loop"><span class="keyword">val</span> mcast_set_loop</span> : <code class="type">Unix.file_descr -> bool -> unit</code></pre><div class="info">
Whether sent multicast messages are received by the sending host<br>
</div>
<pre><span id="VALmcast_set_ttl"><span class="keyword">val</span> mcast_set_ttl</span> : <code class="type">Unix.file_descr -> int -> unit</code></pre><div class="info">
Set TTL/hops value<br>
</div>
<pre><span id="VALmcast_add_membership"><span class="keyword">val</span> mcast_add_membership</span> : <code class="type">Unix.file_descr -> Unix.inet_addr -> Unix.inet_addr -> unit</code></pre><div class="info">
Join a multicast group.
<p>

      First inet addr is the group to join. Second inet addr selects the
      network interface (or <code class="code">Unix.inet_addr_any</code>).<br>
</div>
<pre><span id="VALmcast_drop_membership"><span class="keyword">val</span> mcast_drop_membership</span> : <code class="type">Unix.file_descr -> Unix.inet_addr -> Unix.inet_addr -> unit</code></pre><div class="info">
Leave a multicast group.
<p>

     First inet addr is the group to leave. Second inet addr selects the
     network interface (or <code class="code">Unix.inet_addr_any</code>).<br>
</div>
<br>
<h1 id="1_Profiling">Profiling</h1><br>
<pre><span id="VALmoncontrol"><span class="keyword">val</span> moncontrol</span> : <code class="type">bool -> unit</code></pre><div class="info">
Interface to the <code class="code">moncontrol</code> routine of the GPROF profiler. 
      <code class="code">moncontrol false</code> stops profiling; <code class="code">moncontrol true</code> starts
      profiling again.
<p>

      This is a no-op if the program is not compiler for profiling.<br>
</div>
<br>
<h1 id="1_Deprecated">Deprecated</h1><br>
<br>
The following interfaces have been replaced by more generic implementations
    that work on more platforms.<br>
<pre><span id="VALblocking_read"><span class="keyword">val</span> blocking_read</span> : <code class="type">Unix.file_descr -> string -> int -> int -> int</code></pre><div class="info">
Same as <code class="code">blocking_gread `Read_write</code><br>
</div>
<pre><span id="VALreally_read"><span class="keyword">val</span> really_read</span> : <code class="type">Unix.file_descr -> string -> int -> int -> unit</code></pre><div class="info">
Same as <code class="code">really_gread `Read_write</code><br>
</div>
<pre><span id="VALreally_write"><span class="keyword">val</span> really_write</span> : <code class="type">Unix.file_descr -> string -> int -> int -> unit</code></pre><div class="info">
Same as <code class="code">really_gwrite `Read_write</code><br>
</div>
<br>
The following interfaces have been moved to <a href="Netsys_posix.html"><code class="code">Netsys_posix</code></a>.<br>
<pre><span id="TYPEshm_open_flag"><span class="keyword">type</span> <code class="type"></code>shm_open_flag</span> = <code class="type"><a href="Netsys_posix.html#TYPEshm_open_flag">Netsys_posix.shm_open_flag</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTshm_open_flag.SHM_O_RDONLY"><span class="constructor">SHM_O_RDONLY</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTshm_open_flag.SHM_O_RDWR"><span class="constructor">SHM_O_RDWR</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTshm_open_flag.SHM_O_CREAT"><span class="constructor">SHM_O_CREAT</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTshm_open_flag.SHM_O_EXCL"><span class="constructor">SHM_O_EXCL</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTshm_open_flag.SHM_O_TRUNC"><span class="constructor">SHM_O_TRUNC</span></span></code></td>

</tr></table>


<pre><span id="VALhave_posix_shm"><span class="keyword">val</span> have_posix_shm</span> : <code class="type">unit -> bool</code></pre><pre><span id="VALshm_open"><span class="keyword">val</span> shm_open</span> : <code class="type">string -> <a href="Netsys.html#TYPEshm_open_flag">shm_open_flag</a> list -> int -> Unix.file_descr</code></pre><pre><span id="VALshm_unlink"><span class="keyword">val</span> shm_unlink</span> : <code class="type">string -> unit</code></pre><br>
<h1 id="1_FurtherDocumentation">Further Documentation</h1><br>
<br>
<h2 id="2_HowtoorderlycloseIOchannels">How to orderly close I/O channels</h2> 
<p>

    After reading from uni-directional descriptors, and seeing the
    EOF, it is usually sufficient to call <code class="code">gclose</code> to free OS resources.
<p>

    After writing to uni-directional descriptors one should call
    <code class="code">gshutdown</code> to send an EOF (<code class="code">SHUTDOWN_SEND</code>). For some descriptors
    one will get the exception <code class="code">Shutdown_not_supported</code> which can be
    ignored in this context The <code class="code">gshutdown</code> function cannot,
    however, report in all cases whether the operation was successful.
    As a rule of thumb, error reporting works for local data connections,
    but not always for remote connections, and there is no way to fix
    this. After writing EOF, call <code class="code">gclose</code> to free OS resources.
<p>

    For bidirectional connections, it is even more complicated. If the
    connection is local, a bidirectional connection behaves much like a pair
    of unidirectional connections. However, in the network case, we have
    to go down to the protocol level.
<p>

    For TCP the golden rule is that the client initiates the connection,
    and the client finishes the connection. The case that the server
    finishes the connection is not well-specified - or better, the server needs
    the ACK from the client after triggering the connection termination. 
    In practice we have the cases:
<p>
<ul>
<li>Client sends EOF, and server replies with EOF: This is the normal
      case for which TCP is designed. Client code can invoke
      <code class="code">gshutdown</code> with <code class="code">SHUTDOWN_SEND</code> and then waits until the EOF from 
      the server arrives,
      and then <code class="code">gclose</code>s the descriptor. It may happen that the client
      gets an error if some problem occurs, so this is reliable from the
      perspective of the client. The server first sees the EOF from the
      client, and then responds with another <code class="code">gshutdown</code>, followed by 
      <code class="code">gclose</code>. From the server's perspective it does not matter whether
      the operation results in an error or not - the client has lost
      interest anyway.</li>
<li>Client sends EOF, and server replies with data, and then EOF.
      Here, the client has to read the final data, and then wait for the
      server's EOF after sending its own EOF. On the server's side, 
      some data is written before the final EOF. The question is how
      the server can be sure that the data really arrived. Unfortunately,
      there is no way to do so. The server may not get all errors because
      these may arrive at the server computer after <code class="code">gshutdown</code>. There
      is no way to fix this. (One should better fix the application protocol. 
      Note
      that even prominent researchers trapped into this problem. For example,
      the first version of HTTP had this problem.)</li>
<li>Server sends EOF, and client replies with EOF: This is the difficult
      case. Here, the server wants to be sure that the data sent immediately
      before its EOF really arrives at the client. After <code class="code">gshutdown</code>
      it is forbidden to immediately <code class="code">gclose</code>, because this may result
      in a connection reset. Instead, the server has to wait for the 
      client's EOF. (This is called "lingering".) If the client's EOF is
      seen one can <code class="code">gclose</code>.</li>
<li>Server sends EOF, and client replies with data, followed by EOF:
      I admit I don't know whether TCP can handle this somehow.</li>
</ul>
<br>
<br>
<h1 id="1_Debugging">Debugging</h1><br>
<pre><span class="keyword">module</span> <a href="Netsys.Debug.html">Debug</a>: <code class="code">sig</code> <a href="Netsys.Debug.html">..</a> <code class="code">end</code></pre></body></html>