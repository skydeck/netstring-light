<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Uq_resolver.html">
<link rel="next" href="Uq_socks5.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Uq_mt" rel="Chapter" href="Uq_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Equeue_howto" rel="Chapter" href="Equeue_howto.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netunichar" rel="Chapter" href="Netunichar.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netsys_sem" rel="Chapter" href="Netsys_sem.html">
<link title="Netsys_pmanage" rel="Chapter" href="Netsys_pmanage.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><link title="Exceptions" rel="Section" href="#1_Exceptions">
<link title="Engine definition" rel="Section" href="#1_Enginedefinition">
<link title="Engines and callbacks" rel="Section" href="#1_Enginesandcallbacks">
<link title="Combinators" rel="Section" href="#1_Combinators">
<link title="Basic I/O engines" rel="Section" href="#1_BasicIOengines">
<link title="Transfer engines" rel="Section" href="#1_Transferengines">
<link title="Socket engines" rel="Section" href="#1_Socketengines">
<link title="Multiplex Controllers" rel="Section" href="#1_MultiplexControllers">
<link title="Recursion" rel="Section" href="#1_Recursion">
<link title="More Engines" rel="Section" href="#1_MoreEngines">
<link title="Debugging" rel="Section" href="#1_Debugging">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<link title="Client sockets" rel="Subsection" href="#2_Clientsockets">
<link title="Server sockets" rel="Subsection" href="#2_Serversockets">
<link title="Datagrams" rel="Subsection" href="#2_Datagrams">
<title>Ocamlnet 3 Reference Manual : Uq_engines</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Uq_resolver.html" title="Uq_resolver">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Uq_socks5.html" title="Uq_socks5">Next</a>
</div>
<h1>Module <a href="type_Uq_engines.html">Uq_engines</a></h1>
<pre><span class="keyword">module</span> Uq_engines: <code class="code">sig</code> <a href="Uq_engines.html">..</a> <code class="code">end</code></pre><div class="info">
An <b>engine</b> performs a certain task in an autonomous way. Engines
 are attached to a <a href="Unixqueue.event_system-c.html"><code class="code">Unixqueue.event_system</code></a>, and do their task by
 generating events for resources of the operating system, and 
 by handling such events. Engines are in one of four states: They
 may be still <b>working</b>, they may be <b>done</b>, they may be
 <b>aborted</b>, or they may be in an <b>error</b> state. The three latter
 states a called <b>final states</b>, because they indicate that the
 engine has stopped operation.
<p>

 It is possible to ask an engine to notify another object when it
 changes its state. For simplicity, notification is done by invoking
 a callback function, and not by issuing notification events.
<p>

 Effectively, engines provide a calculus for cooperative microthreading.
 This calculus includes combinators for sequential execution and
 synchronization. Moreover, it is easy to connect it with callback-style
 microthreading - one can arrange callbacks when an engine is done, and
 one can catch callbacks and turn them into engines.<br>
</div>
<hr width="100%">
<br>
<h1 id="1_Exceptions">Exceptions</h1><br>
<pre><span id="EXCEPTIONClosed_channel"><span class="keyword">exception</span> Closed_channel</span></pre>
<div class="info">
Raised when a method of a closed channel object is called (only channel
 methods count).
<p>

 This exception should be regarded as equivalent to
 <code class="code">Netchannels.Closed_channel</code>, but need not be the same exception.<br>
</div>
<pre><span id="EXCEPTIONBroken_communication"><span class="keyword">exception</span> Broken_communication</span></pre>
<div class="info">
Some engines indicate this error when they cannot continue because the
 other endpoint of communication signals an error.
<p>

 This exception is not raised, but used as argument of the <code class="code">`Error</code>
 state.<br>
</div>
<pre><span id="EXCEPTIONWatchdog_timeout"><span class="keyword">exception</span> Watchdog_timeout</span></pre>
<div class="info">
Used by the watchdog engine to indicate a timeout. 
<p>

 This exception is not raised, but used as argument of the <code class="code">`Error</code>
 state.<br>
</div>
<pre><span id="EXCEPTIONTimeout"><span class="keyword">exception</span> Timeout</span></pre>
<div class="info">
Used by <code class="code">input_engine</code> and <code class="code">output_engine</code> to indicate timeouts<br>
</div>
<pre><span id="EXCEPTIONAddressing_method_not_supported"><span class="keyword">exception</span> Addressing_method_not_supported</span></pre>
<div class="info">
Raised by <code class="code">client_socket_connector</code> and <code class="code">server_socket_acceptor</code> to
 indicate that the passed address is not supported by the class.<br>
</div>
<pre><span id="EXCEPTIONCancelled"><span class="keyword">exception</span> Cancelled</span></pre>
<div class="info">
The callback function of a <code class="code">multiplex_controller</code> is invoked with this
 exception if the operation is cancelled.<br>
</div>
<br>
<h1 id="1_Enginedefinition">Engine definition</h1><br>
<pre><span id="TYPEengine_state"><span class="keyword">type</span> <code class="type">'t</code> engine_state</span> = <code class="type">[ `Aborted | `Done of 't | `Error of exn | `Working of int ]</code> </pre>
<div class="info">
The type of states with result values of type <code class="code">'t</code>:<ul>
<li><code class="code">`Working n</code>: The engine is working. The number <code class="code">n</code> counts the number
   of events that have been processed.</li>
<li><code class="code">`Done arg</code>: The engine has completed its task without errors. 
   The argument <code class="code">arg</code> is the result value of the engine</li>
<li><code class="code">`Error exn</code>: The engine has aborted because of an error. The
   argument <code class="code">exn</code> describes the error as an exception.</li>
<li><code class="code">`Aborted</code>: The engine has aborted because the <code class="code">abort</code> method
   was called</li>
</ul>
<br>
</div>

<pre><span id="TYPEfinal_state"><span class="keyword">type</span> <code class="type">'t</code> final_state</span> = <code class="type">[ `Aborted | `Done of 't | `Error of exn ]</code> </pre>
<div class="info">
Same as <code class="code">engine_state</code> without <code class="code">`Working</code>. These are only the final
	states.<br>
</div>

<pre><span id="VALstring_of_state"><span class="keyword">val</span> string_of_state</span> : <code class="type">'a <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> string</code></pre><div class="info">
For debug purposes: Returns a string describing the state<br>
</div>
<pre><span id="TYPEengine"><span class="keyword">class type</span> <code class="type">['t]</code> <a href="Uq_engines.engine-c.html">engine</a></span> = <code class="code">object</code> <a href="Uq_engines.engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
This class type defines the interface an engine must support.
</div>
<pre><span name="TYPEdelegate_engine"><span class="keyword">class</span> <code class="type">['t]</code> <a href="Uq_engines.delegate_engine-c.html">delegate_engine</a></span> : <code class="type">'t #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['t]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Turns an engine value into a class
</div>
<br>
<h1 id="1_Enginesandcallbacks">Engines and callbacks</h1><br>
<pre><span id="VALwhen_state"><span class="keyword">val</span> when_state</span> : <code class="type">?is_done:('a -> unit) -><br>       ?is_error:(exn -> unit) -><br>       ?is_aborted:(unit -> unit) -><br>       ?is_progressing:(int -> unit) -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> unit</code></pre><div class="info">
Watches the state of the argument engine, and arranges that one of
 the functions is called when the corresponding state change is done. 
 Once a final state is reached, the engine is no longer watched.
 Note that <code class="code">when_state</code> only observes future state changes.
<p>

 If one of the functions raises an exception, this exception is
 propagated to the caller of <a href="Unixqueue.html#VALrun"><code class="code">Unixqueue.run</code></a>.
<p>

<br>
</div>
<div class="param_info"><code class="code">is_done</code> : The state transitions to <code class="code">`Done</code>. The argument of
   <code class="code">is_done</code> is the argument of the <code class="code">`Done</code> state.</div>
<div class="param_info"><code class="code">is_error</code> : The state transitions to <code class="code">`Error</code>. The argument of
   <code class="code">is_error</code> is the argument of the <code class="code">`Error</code> state.</div>
<div class="param_info"><code class="code">is_aborted</code> : The state transitions to <code class="code">`Aborted</code>.</div>
<div class="param_info"><code class="code">is_progressing</code> : This function is called when the <code class="code">`Working</code>
   state changes. The int argument is the new <code class="code">`Working</code> arg.</div>
<pre><span name="TYPEsignal_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.signal_engine-c.html">signal_engine</a></span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="code">object</code> <a href="Uq_engines.signal_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">let se = new signal_engine esys</code>: The engine <code class="code">se</code> remains in
      <code class="code">`Working 0</code> until the method <code class="code">se # signal x</code> is called.
</div>
<pre><span id="VALsignal_engine"><span class="keyword">val</span> signal_engine</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -><br>       'a <a href="Uq_engines.engine-c.html">engine</a> * ('a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> -> unit)</code></pre><div class="info">
<code class="code">let (se, signal) = signal_engine esys</code>: Same as function<br>
</div>
<br>
<h1 id="1_Combinators">Combinators</h1><br>
<br>
The following combinators serve as the control structures to connect
    primitive engines with each other.<br>
<pre><span name="TYPEmap_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.map_engine-c.html">map_engine</a></span> : <code class="type">map_done:('a -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -> ?map_error:exn -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> ?map_aborted:unit -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> ?propagate_working:bool -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
The <code class="code">map_engine</code> observes the argument engine, and when the
 state changes to <code class="code">`Done</code>, <code class="code">`Error</code>, or <code class="code">`Aborted</code>, the corresponding
 mapping function is called, and the resulting state becomes the state
 of the mapped engine.
</div>
<pre><span id="VALmap_engine"><span class="keyword">val</span> map_engine</span> : <code class="type">map_done:('a -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -><br>       ?map_error:(exn -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -><br>       ?map_aborted:(unit -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -><br>       ?propagate_working:bool -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEfmap_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.fmap_engine-c.html">fmap_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> ('a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> -> 'b <a href="Uq_engines.html#TYPEfinal_state">final_state</a>) -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Similar to <code class="code">map_engine</code> but different calling conventions: The
      mapping function is called when the argument engine reaches a
      final state, and this state can be mapped to another final state.
</div>
<pre><span id="VALfmap_engine"><span class="keyword">val</span> fmap_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -><br>       ('a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> -> 'b <a href="Uq_engines.html#TYPEfinal_state">final_state</a>) -><br>       'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function
<p>

      After opening <a href="Uq_engines.Operators.html"><code class="code">Uq_engines.Operators</code></a>, this is also available
      as operator <code class="code">&gt;&gt;</code>, e.g.
<p>

      <pre class="codepre"><code class="code"> 
         e &gt;&gt;
           (function
             | `Done r -&gt; ...
             | `Error error -&gt; ...
             | `Aborted -&gt; ...
           )
       </code></pre><br>
</div>
<pre><span name="TYPEmeta_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.meta_engine-c.html">meta_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['a <a href="Uq_engines.html#TYPEfinal_state">final_state</a>]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
maps the final state <code class="code">s</code> to <code class="code">`Done s</code>
</div>
<pre><span id="VALmeta_engine"><span class="keyword">val</span> meta_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEepsilon_engine"><span class="keyword">class</span> <code class="type">['t]</code> <a href="Uq_engines.epsilon_engine-c.html">epsilon_engine</a></span> : <code class="type">'t <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['t]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine transitions from its initial state <code class="code">`Working 0</code> in one
 step ("epsilon time") to the passed constant state.
</div>
<pre><span id="VALepsilon_engine"><span class="keyword">val</span> epsilon_engine</span> : <code class="type">'t <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 't <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEseq_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.seq_engine-c.html">seq_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> ('a -> 'b #<a href="Uq_engines.engine-c.html">engine</a>) -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine runs two engines in sequential order.
</div>
<pre><span id="VALseq_engine"><span class="keyword">val</span> seq_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -><br>       ('a -> 'b #<a href="Uq_engines.engine-c.html">engine</a>) -> 'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function.
<p>

 After opening <a href="Uq_engines.Operators.html"><code class="code">Uq_engines.Operators</code></a>, this is also available
 as operator <code class="code">++</code>, e.g.
 <pre class="codepre"><code class="code"> e1 ++ (fun r1 -&gt; e2) </code></pre>
 (when <code class="code">e1</code> and <code class="code">e2</code> are engines, and <code class="code">r1</code> is the result of <code class="code">e1</code>).<br>
</div>
<pre><span name="TYPEstream_seq_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.stream_seq_engine-c.html">stream_seq_engine</a></span> : <code class="type">'a -> ('a -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) Stream.t -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<code class="code">let se = new stream_seq_engine x0 s esys</code>: The constructed engine <code class="code">se</code>
 fetches functions <code class="code">f : 'a -&gt; 'a #engine</code> from the stream <code class="code">s</code>, and
 runs the engines obtained by calling these functions <code class="code">e = f x</code> one
 after the other.
</div>
<pre><span id="VALstream_seq_engine"><span class="keyword">val</span> stream_seq_engine</span> : <code class="type">'a -><br>       ('a -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) Stream.t -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEsync_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.sync_engine-c.html">sync_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'b #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">[('a * 'b)]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine runs two engines in parallel, and waits until both
 are <code class="code">`Done</code> (synchronization).
</div>
<pre><span id="VALsync_engine"><span class="keyword">val</span> sync_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'b #<a href="Uq_engines.engine-c.html">engine</a> -> ('a * 'b) <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEmsync_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.msync_engine-c.html">msync_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> list -> ('a -> 'b -> 'b) -> 'b -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Multiple synchronization: 
      <code class="code">let me = new msync_engine el f x0 esys</code> - Runs the engines in <code class="code">el</code> in
      parallel, and waits until all are <code class="code">`Done</code>.
</div>
<pre><span id="VALmsync_engine"><span class="keyword">val</span> msync_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> list -><br>       ('a -> 'b -> 'b) -> 'b -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEdelay_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.delay_engine-c.html">delay_engine</a></span> : <code class="type">float -> (unit -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<code class="code">let de = delay_engine d f esys</code>: The engine <code class="code">e = f()</code> is created
      after <code class="code">d</code> seconds, and the result of <code class="code">e</code> becomes the result of <code class="code">de</code>.
</div>
<pre><span id="VALdelay_engine"><span class="keyword">val</span> delay_engine</span> : <code class="type">float -><br>       (unit -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEtimeout_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.timeout_engine-c.html">timeout_engine</a></span> : <code class="type">float -> exn -> 'a <a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<code class="code">timeout_engine d x e</code>: If the engine <code class="code">e</code> finishes within <code class="code">d</code>
      seconds, the result remains unchanged.
</div>
<pre><span id="VALtimeout_engine"><span class="keyword">val</span> timeout_engine</span> : <code class="type">float -> exn -> 'a <a href="Uq_engines.engine-c.html">engine</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEwatchdog"><span class="keyword">class</span> <a href="Uq_engines.watchdog-c.html">watchdog</a></span> : <code class="type">float -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
A watchdog engine checks whether the argument engine makes
 progress, and if there is no progress for the passed number of
 seconds, the engine is aborted, and the watchdog state changes
 to <code class="code">`Error Watchdog_timeout</code>.
</div>
<pre><span id="VALwatchdog"><span class="keyword">val</span> watchdog</span> : <code class="type">float -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> unit <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span id="TYPEserializer_t"><span class="keyword">class type</span> <code class="type">['a]</code> <a href="Uq_engines.serializer_t-c.html">serializer_t</a></span> = <code class="code">object</code> <a href="Uq_engines.serializer_t-c.html">..</a> <code class="code">end</code></pre><div class="info">
A serializer queues up engines, and starts the next engine when the
      previous one finishes.
</div>
<pre><span name="TYPEserializer"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.serializer-c.html">serializer</a></span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.serializer_t-c.html">serializer_t</a></code></pre><div class="info">
Creates a serializer
</div>
<pre><span id="VALserializer"><span class="keyword">val</span> serializer</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.serializer_t-c.html">serializer_t</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span id="TYPEprioritizer_t"><span class="keyword">class type</span> <code class="type">['a]</code> <a href="Uq_engines.prioritizer_t-c.html">prioritizer_t</a></span> = <code class="code">object</code> <a href="Uq_engines.prioritizer_t-c.html">..</a> <code class="code">end</code></pre><div class="info">
A prioritizer allows to prioritize the execution of engines: At any
    time, only engines of a certain priority <code class="code">p</code> can be executed.
</div>
<pre><span name="TYPEprioritizer"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.prioritizer-c.html">prioritizer</a></span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.prioritizer_t-c.html">prioritizer_t</a></code></pre><div class="info">
Creates a prioritizer
</div>
<pre><span id="VALprioritizer"><span class="keyword">val</span> prioritizer</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.prioritizer_t-c.html">prioritizer_t</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span id="TYPEcache_t"><span class="keyword">class type</span> <code class="type">['a]</code> <a href="Uq_engines.cache_t-c.html">cache_t</a></span> = <code class="code">object</code> <a href="Uq_engines.cache_t-c.html">..</a> <code class="code">end</code></pre><div class="info">
A cache contains a mutable value that is obtained by running an
    engine.
</div>
<pre><span name="TYPEcache"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.cache-c.html">cache</a></span> : <code class="type">(<a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a>) -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.cache_t-c.html">cache_t</a></code></pre><div class="info">
<code class="code">new cache f esys</code>: A cache that runs <code class="code">f esys</code> to obtain values
</div>
<pre><span id="VALcache"><span class="keyword">val</span> cache</span> : <code class="type">(<a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a>) -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.cache_t-c.html">cache_t</a></code></pre><div class="info">
Same as function<br>
</div>
<pre><span name="TYPEengine_mixin"><span class="keyword">class</span> <code class="type">['t]</code> <a href="Uq_engines.engine_mixin-c.html">engine_mixin</a></span> : <code class="type">'t <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="code">object</code> <a href="Uq_engines.engine_mixin-c.html">..</a> <code class="code">end</code></pre><div class="info">
A useful class fragment that implements <code class="code">state</code> and 
 <code class="code">request_notification</code>.
</div>
<pre><span class="keyword">module</span> <a href="Uq_engines.Operators.html">Operators</a>: <code class="code">sig</code> <a href="Uq_engines.Operators.html">..</a> <code class="code">end</code></pre><div class="info">
Handy operators: <code class="code">++</code>, <code class="code">&gt;&gt;</code>, and <code class="code">eps_e</code>
</div>
<br>
<h1 id="1_BasicIOengines">Basic I/O engines</h1><br>
<pre><span name="TYPEpoll_engine"><span class="keyword">class</span> <a href="Uq_engines.poll_engine-c.html">poll_engine</a></span> : <code class="type">?extra_match:exn -> bool -> (<a href="Unixqueue.html#TYPEoperation">Unixqueue.operation</a> * float) list -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="code">object</code> <a href="Uq_engines.poll_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
This engine waits until one of the passed operations can be 
 carried out, or until one of the operations times out.
</div>
<pre><span name="TYPEinput_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.input_engine-c.html">input_engine</a></span> : <code class="type">(Unix.file_descr -> 'a) -> Unix.file_descr -> float -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Generic input engine for reading from a file descriptor:
      <code class="code">let e = new input_engine f fd tmo</code> - Waits until the file descriptor
      becomes readable, and calls then <code class="code">let x = f fd</code> to read from the
      descriptor.
</div>
<pre><span name="TYPEoutput_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.output_engine-c.html">output_engine</a></span> : <code class="type">(Unix.file_descr -> 'a) -> Unix.file_descr -> float -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Generic output engine for writing to a file descriptor:
      <code class="code">let e = new output_engine f fd tmo</code> - Waits until the file descriptor
      becomes writable, and calls then <code class="code">let x = f fd</code> to write to the
      descriptor.
</div>
<pre><span name="TYPEpoll_process_engine"><span class="keyword">class</span> <a href="Uq_engines.poll_process_engine-c.html">poll_process_engine</a></span> : <code class="type">?period:float -> pid:int -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">[Unix.process_status]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<b>This class is deprecated!</b> Use the classes in <a href="Shell_uq.html"><code class="code">Shell_uq</code></a> instead.
</div>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h1 id="1_Transferengines">Transfer engines</h1><br>
<br>
Transfer engines copy data between file descriptors. This kind
    of engine is likely to be declared as deprecated in
    the future. If possible, one should use multiplex controllers
    (see below), and for copying streams the generic copier 
    <a href="Uq_io.html#VALcopy_e"><code class="code">Uq_io.copy_e</code></a> is a better choice.
<p>

    The pure types <code class="code">async_in_channel</code> and <code class="code">async_out_channel</code> have been
    proven to be useful for bridging with <a href="Netchannels.html"><code class="code">Netchannels</code></a>.<br>
<pre><span id="TYPEasync_out_channel"><span class="keyword">class type</span> <a href="Uq_engines.async_out_channel-c.html">async_out_channel</a></span> = <code class="code">object</code> <a href="Uq_engines.async_out_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
An asynchrounous output channel provides methods to output data to
 a stream descriptor.
</div>
<pre><span id="TYPEasync_in_channel"><span class="keyword">class type</span> <a href="Uq_engines.async_in_channel-c.html">async_in_channel</a></span> = <code class="code">object</code> <a href="Uq_engines.async_in_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
An asynchrounous input channel provides methods to input data from
 a stream descriptor.
</div>
<pre><span name="TYPEpseudo_async_out_channel"><span class="keyword">class</span> <a href="Uq_engines.pseudo_async_out_channel-c.html">pseudo_async_out_channel</a></span> : <code class="type">#<a href="Netchannels.raw_out_channel-c.html">Netchannels.raw_out_channel</a> -> </code><code class="type"><a href="Uq_engines.async_out_channel-c.html">async_out_channel</a></code></pre><div class="info">
Takes a <a href="Netchannels.raw_out_channel-c.html"><code class="code">Netchannels.raw_out_channel</code></a> as an asynchronous channel.
</div>
<pre><span name="TYPEpseudo_async_in_channel"><span class="keyword">class</span> <a href="Uq_engines.pseudo_async_in_channel-c.html">pseudo_async_in_channel</a></span> : <code class="type">#<a href="Netchannels.raw_in_channel-c.html">Netchannels.raw_in_channel</a> -> </code><code class="type"><a href="Uq_engines.async_in_channel-c.html">async_in_channel</a></code></pre><div class="info">
Takes a <a href="Netchannels.raw_in_channel-c.html"><code class="code">Netchannels.raw_in_channel</code></a> as an asynchronous channel.
</div>
<pre><span name="TYPEreceiver"><span class="keyword">class</span> <a href="Uq_engines.receiver-c.html">receiver</a></span> : <code class="type">src:Unix.file_descr -> dst:#<a href="Uq_engines.async_out_channel-c.html">async_out_channel</a> -> ?close_src:bool -> ?close_dst:bool -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine copies all data from the <code class="code">src</code> file descriptor to the
 <code class="code">dst</code> output channel.
</div>
<pre><span name="TYPEsender"><span class="keyword">class</span> <a href="Uq_engines.sender-c.html">sender</a></span> : <code class="type">src:#<a href="Uq_engines.async_in_channel-c.html">async_in_channel</a> -> dst:Unix.file_descr -> ?close_src:bool -> ?close_dst:bool -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine copies all data from the <code class="code">src</code> input channel to the
 <code class="code">dst</code> file descriptor.
</div>
<pre><span id="TYPEasync_out_channel_engine"><span class="keyword">class type</span> <a href="Uq_engines.async_out_channel_engine-c.html">async_out_channel_engine</a></span> = <code class="code">object</code> <a href="Uq_engines.async_out_channel_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
Combination of engine + async_out_channel
</div>
<pre><span id="TYPEasync_in_channel_engine"><span class="keyword">class type</span> <a href="Uq_engines.async_in_channel_engine-c.html">async_in_channel_engine</a></span> = <code class="code">object</code> <a href="Uq_engines.async_in_channel_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
Combination of engine + async_in_channel
</div>
<pre><span name="TYPEoutput_async_descr"><span class="keyword">class</span> <a href="Uq_engines.output_async_descr-c.html">output_async_descr</a></span> : <code class="type">dst:Unix.file_descr -> ?buffer_size:int -> ?close_dst:bool -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type"><a href="Uq_engines.async_out_channel_engine-c.html">async_out_channel_engine</a></code></pre><div class="info">
This engine implements an <code class="code">async_out_channel</code> for the output
 descriptor <code class="code">dst</code>.
</div>
<pre><span name="TYPEinput_async_descr"><span class="keyword">class</span> <a href="Uq_engines.input_async_descr-c.html">input_async_descr</a></span> : <code class="type">src:Unix.file_descr -> ?buffer_size:int -> ?close_src:bool -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type"><a href="Uq_engines.async_in_channel_engine-c.html">async_in_channel_engine</a></code></pre><div class="info">
The corresponding class for asynchronous input channels.
</div>
<pre><span id="TYPEcopy_task"><span class="keyword">type</span> <code class="type"></code>copy_task</span> = <code class="type">[ `Bidirectional of Unix.file_descr * Unix.file_descr<br>       | `Tridirectional of Unix.file_descr * Unix.file_descr * Unix.file_descr<br>       | `Uni_socket of Unix.file_descr * Unix.file_descr<br>       | `Unidirectional of Unix.file_descr * Unix.file_descr ]</code> </pre>
<div class="info">
Specifies the task the <code class="code">copier</code> class has to do:
<p>
<ul>
<li><code class="code">`Unidirectional(src,dst)</code>: Data from <code class="code">src</code> are copied to <code class="code">dst</code>.
   EOF of <code class="code">src</code> causes that both descriptors are closed.</li>
<li><code class="code">`Uni_socket(src,dst)</code>: Data from <code class="code">src</code> are copied to <code class="code">dst</code>.
   EOF of <code class="code">src</code> causes that <code class="code">dst</code> is shut down for sending; all descriptors
   remain open. It is required that <code class="code">dst</code> is a socket.</li>
<li><code class="code">`Bidirectional(bi1,bi2)</code>: Data from <code class="code">bi1</code> are copied to <code class="code">bi2</code>,
   and data from <code class="code">bi2</code> are copied to <code class="code">bi1</code>. EOF of one descriptor
   causes that the other descriptor is shut down for sending.
   When both descriptors are at EOF, both are closed.
   It is required that <code class="code">bi1</code> and <code class="code">bi2</code> are sockets.</li>
<li><code class="code">`Tridirectional(bi,dst,src)</code>: Data from <code class="code">bi</code> are copied to <code class="code">dst</code>,
   and data from <code class="code">src</code> are copied to <code class="code">bi</code> (i.e. a bidirectional
   descriptor is split up into two unidirectional descriptors). 
   EOF of <code class="code">bi</code> causes that <code class="code">dst</code> is closed. EOF of <code class="code">src</code> causes
   that <code class="code">bi</code> is shut down for sending. EOF in both directions 
   causes that all descriptors are closed. It is required that
   <code class="code">bi</code> is a socket.</li>
</ul>
<br>
</div>

<pre><span name="TYPEcopier"><span class="keyword">class</span> <a href="Uq_engines.copier-c.html">copier</a></span> : <code class="type"><a href="Uq_engines.html#TYPEcopy_task">copy_task</a> -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine copies data between file descriptors as specified by
 the <code class="code">copy_task</code> argument.
</div>
<br>
<h1 id="1_Socketengines">Socket engines</h1><br>
<br>
Note that Win32 named pipes are also supported by the following
    API's, although they are not sockets. These pipes have a feature
    set comparable to Unix domain sockets.<br>
<pre><span id="TYPEinetspec"><span class="keyword">type</span> <code class="type"></code>inetspec</span> = <code class="type">[ `Sock_inet of Unix.socket_type * Unix.inet_addr * int<br>       | `Sock_inet_byname of Unix.socket_type * string * int ]</code> </pre>

<pre><span id="TYPEsockspec"><span class="keyword">type</span> <code class="type"></code>sockspec</span> = <code class="type">[ `Sock_inet of Unix.socket_type * Unix.inet_addr * int<br>       | `Sock_inet_byname of Unix.socket_type * string * int<br>       | `Sock_unix of Unix.socket_type * string ]</code> </pre>
<div class="info">
Extended names for socket addresses. Currently, these naming schemes
 are supported:<ul>
<li><code class="code">`Sock_unix(stype,path)</code>: Names the Unix domain socket at <code class="code">path</code>.
   The socket type <code class="code">stype</code> is an auxiliary piece of information, but
   not a distinguishing part of the name. <code class="code">path = ""</code> refers to 
   anonymous sockets. Otherwise, the <code class="code">path</code> must be an absolute path name.</li>
<li><code class="code">`Sock_inet(stype,addr,port)</code>: Names the Internet socket of type
   <code class="code">stype</code> bound to the IP address <code class="code">addr</code> and the <code class="code">port</code>.
   If <code class="code">stype = Unix.SOCK_STREAM</code>, a TCP socket is meant, and if 
   <code class="code">stype = Unix.SOCK_DGRAM</code>, a UDP socket is meant. It is allowed
   that <code class="code">addr = Unix.inet_addr_any</code>. If <code class="code">port = 0</code>, the name is to
   be considered as incomplete.</li>
<li><code class="code">`Sock_inet_byname(stype,name,port)</code>: Names the Internet socket of
   type <code class="code">stype</code> bound to the IP address corresponding to the 
   <code class="code">name</code>, and bound to the <code class="code">port</code>. It is unspecified which naming
   service is used to resolve <code class="code">name</code> to an IP address, and how it is
   used. If the <code class="code">name</code> cannot be resolved, no socket is meant; this
   is usually an error. <code class="code">stype</code> is interpreted as for <code class="code">`Sock_inet</code>.
   If <code class="code">port = 0</code>, the name is to be considered as incomplete.</li>
</ul>

 It is currently not possible to name IP sockets that are bound to
 several IP addresses but not all IP addresses of the host.<br>
</div>

<pre><span id="VALsockspec_of_sockaddr"><span class="keyword">val</span> sockspec_of_sockaddr</span> : <code class="type">Unix.socket_type -> Unix.sockaddr -> <a href="Uq_engines.html#TYPEsockspec">sockspec</a></code></pre><div class="info">
Converts a normal socket address to the extended form<br>
</div>
<pre><span id="VALsockspec_of_socksymbol"><span class="keyword">val</span> sockspec_of_socksymbol</span> : <code class="type">Unix.socket_type -> <a href="Netsockaddr.html#TYPEsocksymbol">Netsockaddr.socksymbol</a> -> <a href="Uq_engines.html#TYPEsockspec">sockspec</a></code></pre><div class="info">
Converts a <a href="Netsockaddr.html#TYPEsocksymbol"><code class="code">Netsockaddr.socksymbol</code></a> to this form<br>
</div>
<br>
<h2 id="2_Clientsockets">Client sockets</h2><br>
<pre><span id="TYPEconnect_address"><span class="keyword">type</span> <code class="type"></code>connect_address</span> = <code class="type">[ `Command of string * (int -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> unit)<br>       | `Socket of <a href="Uq_engines.html#TYPEsockspec">sockspec</a> * <a href="Uq_engines.html#TYPEconnect_options">connect_options</a><br>       | `W32_pipe of <a href="Netsys_win32.html#TYPEpipe_mode">Netsys_win32.pipe_mode</a> * string ]</code> </pre>
<div class="info">
Specifies the service to connect to:
<p>

 <ul>
<li><code class="code">`Socket(addr,opts)</code>: Connect to the passed socket address</li>
<li><code class="code">`Command(cmd,handler)</code>: The <code class="code">cmd</code> is started with the shell, 
   and <code class="code">stdin</code> and <code class="code">stdout</code> are used to transfer data to the
   process and from the process, respectively. Only <code class="code">SOCK_STREAM</code>
   type is supported. Note that the passed file descriptors are
   normal pipes, not sockets (so the descriptors can be individually
   closed).
<p>

   There is not any kind of error detection, so the command should
   be failsafe. <code class="code">stderr</code> of the command is connected with <code class="code">stderr</code> of
   the caller process.
<p>

   No provisions are taken to wait for the process; this is the
   task of the caller. After the process has been started, the
   <code class="code">handler</code> is invoked with the process ID and the event system
   to give the caller a chance to arrange that the process will be
   waited for.</li>
<li><code class="code">`W32_pipe(mode,name)</code>: A Win32 named pipe</li>
</ul>
<br>
</div>

<pre><code><span id="TYPEconnect_options"><span class="keyword">type</span> <code class="type"></code>connect_options</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconnect_options.conn_bind">conn_bind</span>&nbsp;:<code class="type"><a href="Uq_engines.html#TYPEsockspec">sockspec</a> option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Bind the connecting socket to this address (same family as the
 connected socket required). <code class="code">None</code>: Use an anonymous port.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}


<pre><span id="VALdefault_connect_options"><span class="keyword">val</span> default_connect_options</span> : <code class="type"><a href="Uq_engines.html#TYPEconnect_options">connect_options</a></code></pre><div class="info">
Returns the default options<br>
</div>
<pre><span id="TYPEconnect_status"><span class="keyword">type</span> <code class="type"></code>connect_status</span> = <code class="type">[ `Command of Unix.file_descr * int<br>       | `Socket of Unix.file_descr * <a href="Uq_engines.html#TYPEsockspec">sockspec</a><br>       | `W32_pipe of Unix.file_descr ]</code> </pre>
<div class="info">
This type corresponds with <a href="Uq_engines.html#TYPEconnect_address"><code class="code">Uq_engines.connect_address</code></a>: An engine
 connecting with an address `X will return a status of `X.
<p>
<ul>
<li><code class="code">`Socket(fd,addr)</code>: <code class="code">fd</code> is the client socket connected with the
   service. <code class="code">addr</code> is the socket address of the client that must be
   used by the server to reach the client.</li>
<li><code class="code">`Command(fd, pid)</code>: <code class="code">fd</code> is the Unix domain socket connected with
   the running command. <code class="code">pid</code> is the process ID.</li>
<li><code class="code">`W32_pipe fd</code>: <code class="code">fd</code> is the proxy descriptor of the connected
   Win32 named pipe endpoint. See <a href="Netsys_win32.html"><code class="code">Netsys_win32</code></a> how to get the
   <code class="code">w32_pipe</code> object to access the pipe. The proxy descriptor <b>cannot</b>
   be used for I/O.</li>
</ul>
<br>
</div>

<pre><span id="VALclient_endpoint"><span class="keyword">val</span> client_endpoint</span> : <code class="type"><a href="Uq_engines.html#TYPEconnect_status">connect_status</a> -> Unix.file_descr</code></pre><div class="info">
Returns the client endpoint contained in the <code class="code">connect_status</code><br>
</div>
<pre><span id="VALclient_socket"><span class="keyword">val</span> client_socket</span> : <code class="type"><a href="Uq_engines.html#TYPEconnect_status">connect_status</a> -> Unix.file_descr</code></pre><div class="info">
For backward compatibility. <b>Deprecated name</b> for <code class="code">client_endpoint</code><br>
</div>
<pre><span id="TYPEclient_endpoint_connector"><span class="keyword">class type</span> <a href="Uq_engines.client_endpoint_connector-c.html">client_endpoint_connector</a></span> = <code class="code">object</code> <a href="Uq_engines.client_endpoint_connector-c.html">..</a> <code class="code">end</code></pre><div class="info">
This class type provides engines to connect to a service.
</div>
<pre><span id="TYPEclient_socket_connector"><span class="keyword">class type</span> <a href="Uq_engines.client_socket_connector-c.html">client_socket_connector</a></span> = <code class="type"><a href="Uq_engines.client_endpoint_connector-c.html">client_endpoint_connector</a></code></pre><div class="info">
For backward compatibility.
</div>
<pre><span id="VALconnector"><span class="keyword">val</span> connector</span> : <code class="type">?proxy:#<a href="Uq_engines.client_socket_connector-c.html">client_socket_connector</a> -><br>       <a href="Uq_engines.html#TYPEconnect_address">connect_address</a> -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> <a href="Uq_engines.html#TYPEconnect_status">connect_status</a> <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine connects to a socket as specified by the <code class="code">connect_address</code>,
 optionally using the <code class="code">proxy</code>, and changes to the state
 <code class="code">`Done(status)</code> when the connection is established.
<p>

 If the <code class="code">proxy</code> does not support the <code class="code">connect_address</code>, the class 
 will raise <code class="code">Addressing_method_not_supported</code>.
<p>

 The descriptor <code class="code">fd</code> (part of the <code class="code">connect_status</code>) is in non-blocking mode,
 and the close-on-exec flag is set.
 It is the task of the caller to close this descriptor.
<p>

 The engine attaches automatically to the event system, and detaches
 when it is possible to do so. This depends on the type of the
 connection method. For direct socket connections, the engine can
 often detach immediately when the conection is established. For proxy
 connections it is required that the engine
 copies data to and from the file descriptor. In this case, the
 engine detaches when the file descriptor is closed.
<p>

 It is possible that name service queries block execution.
<p>

 If name resolution fails, the engine will enter
 <code class="code">`Error(Uq_resolver.Host_not_found name)</code>. This is <b>new since
 Ocamlnet-3.3</b> - before this version, the exception was simply
 <code class="code">Not_found</code>.<br>
</div>
<br>
<b>Example</b> of using <code class="code">connector</code>: This engine <code class="code">e</code> connects to the
    "echo" service as provided by inetd, sends a line of data to it,
    and awaits the response.
<p>

    <pre class="codepre"><code class="code">	let e =
	  Uq_engines.connector
	    (`Socket(`Sock_inet_byname(Unix.SOCK_STREAM, "localhost", 7),
		     Uq_engines.default_connect_options))
	    esys
	  ++ (fun cs -&gt;
		match cs with
		  | `Socket(fd,_) -&gt;
		      let mplex =
			Uq_engines.create_multiplex_controller_for_connected_socket
			  ~supports_half_open_connection:true
			  fd esys in
		      let d_unbuf = `Multiplex mplex in
		      let d = `Buffer_in(Uq_io.create_in_buffer d_unbuf) in
		      Uq_io.output_string_e d_unbuf "This is line1\n"
		      ++ (fun () -&gt;
			    Uq_io.input_line_e d 
			    ++ (fun s -&gt;
				  print_endline s;
				  eps_e (`Done()) esys
			       )
			 )
		  | _ -&gt; assert false
	     )
    </code></pre><br>
<br>
<h2 id="2_Serversockets">Server sockets</h2><br>
<pre><span id="TYPElisten_address"><span class="keyword">type</span> <code class="type"></code>listen_address</span> = <code class="type">[ `Socket of <a href="Uq_engines.html#TYPEsockspec">sockspec</a> * <a href="Uq_engines.html#TYPElisten_options">listen_options</a><br>       | `W32_pipe of <a href="Netsys_win32.html#TYPEpipe_mode">Netsys_win32.pipe_mode</a> * string * <a href="Uq_engines.html#TYPElisten_options">listen_options</a> ]</code> </pre>
<div class="info">
Specifies the resource to listen on:
<p>
<ul>
<li><code class="code">`Socket(addr,opts)</code>: It is listened on a socket with address <code class="code">addr</code></li>
<li><code class="code">`W32_pipe(mode,name,opts)</code>: It is listened on a pipe server with
   <code class="code">name</code> which accepts pipe connections in <code class="code">mode</code>.</li>
</ul>
<br>
</div>

<pre><code><span id="TYPElisten_options"><span class="keyword">type</span> <code class="type"></code>listen_options</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlisten_options.lstn_backlog">lstn_backlog</span>&nbsp;:<code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >The length of the queue of not yet accepted
 connections.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlisten_options.lstn_reuseaddr">lstn_reuseaddr</span>&nbsp;:<code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Whether to allow that the address can be
 immediately reused after the previous listener
 has its socket shut down. (Only for Internet
 sockets.)</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}


<pre><span id="VALdefault_listen_options"><span class="keyword">val</span> default_listen_options</span> : <code class="type"><a href="Uq_engines.html#TYPElisten_options">listen_options</a></code></pre><div class="info">
Returns the default options<br>
</div>
<pre><span id="TYPEserver_endpoint_acceptor"><span class="keyword">class type</span> <a href="Uq_engines.server_endpoint_acceptor-c.html">server_endpoint_acceptor</a></span> = <code class="code">object</code> <a href="Uq_engines.server_endpoint_acceptor-c.html">..</a> <code class="code">end</code></pre><div class="info">
This class type is for service providers that listen for connections.
</div>
<pre><span id="TYPEserver_socket_acceptor"><span class="keyword">class type</span> <a href="Uq_engines.server_socket_acceptor-c.html">server_socket_acceptor</a></span> = <code class="type"><a href="Uq_engines.server_endpoint_acceptor-c.html">server_endpoint_acceptor</a></code></pre><div class="info">
For backward compatibility.
</div>
<pre><span name="TYPEdirect_acceptor"><span class="keyword">class</span> <a href="Uq_engines.direct_acceptor-c.html">direct_acceptor</a></span> : <code class="type">?close_on_shutdown:bool -> ?preclose:unit -> unit -> Unix.file_descr -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type"><a href="Uq_engines.server_endpoint_acceptor-c.html">server_endpoint_acceptor</a></code></pre><div class="info">
An implementation of <code class="code">server_endpoint_acceptor</code> for sockets and Win32
    named pipes.
</div>
<pre><span name="TYPEdirect_socket_acceptor"><span class="keyword">class</span> <a href="Uq_engines.direct_socket_acceptor-c.html">direct_socket_acceptor</a></span> : <code class="type">Unix.file_descr -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type"><a href="Uq_engines.server_endpoint_acceptor-c.html">server_endpoint_acceptor</a></code></pre><div class="info">
For backward compatibility.
</div>
<pre><span id="TYPEserver_endpoint_listener"><span class="keyword">class type</span> <a href="Uq_engines.server_endpoint_listener-c.html">server_endpoint_listener</a></span> = <code class="code">object</code> <a href="Uq_engines.server_endpoint_listener-c.html">..</a> <code class="code">end</code></pre><div class="info">
This class type represents factories for service providers
</div>
<pre><span id="TYPEserver_socket_listener"><span class="keyword">class type</span> <a href="Uq_engines.server_socket_listener-c.html">server_socket_listener</a></span> = <code class="type"><a href="Uq_engines.server_endpoint_listener-c.html">server_endpoint_listener</a></code></pre><div class="info">
For backward compatibility.
</div>
<pre><span id="VALlistener"><span class="keyword">val</span> listener</span> : <code class="type">?proxy:#<a href="Uq_engines.server_socket_listener-c.html">server_socket_listener</a> -><br>       <a href="Uq_engines.html#TYPElisten_address">listen_address</a> -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> <a href="Uq_engines.server_socket_acceptor-c.html">server_socket_acceptor</a> <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine creates a server socket listening on the <code class="code">listen_address</code>.
 If passed, the <code class="code">proxy</code> is used to create the server socket.
<p>

 On success, the engine goes to state <code class="code">`Done acc</code>, where <code class="code">acc</code> is
 the acceptor object (see above). The acceptor object can be used
 to accept incoming connections.<br>
</div>
<br>
<h2 id="2_Datagrams">Datagrams</h2><br>
<pre><span id="TYPEdatagram_type"><span class="keyword">type</span> <code class="type"></code>datagram_type</span> = <code class="type">[ `Inet6_udp | `Inet_udp | `Unix_dgram ]</code> </pre>
<div class="info">
- <code class="code">`Unix_dgram</code>: Datagrams over Unix domain sockets<ul>
<li><code class="code">`Inet_udp</code>:   Internet v4 UDP protocol</li>
<li><code class="code">`Inet6_udp</code>:   Internet v6 UDP protocol</li>
</ul>
<br>
</div>

<pre><span id="TYPEwrapped_datagram_socket"><span class="keyword">class type</span> <a href="Uq_engines.wrapped_datagram_socket-c.html">wrapped_datagram_socket</a></span> = <code class="code">object</code> <a href="Uq_engines.wrapped_datagram_socket-c.html">..</a> <code class="code">end</code></pre><div class="info">
A <code class="code">wrapped_datagram_socket</code> allows datagrams to be sent via proxies.
</div>
<pre><span id="TYPEdatagram_socket_provider"><span class="keyword">class type</span> <a href="Uq_engines.datagram_socket_provider-c.html">datagram_socket_provider</a></span> = <code class="code">object</code> <a href="Uq_engines.datagram_socket_provider-c.html">..</a> <code class="code">end</code></pre><div class="info">
This is a factory for <code class="code">wrapped_datagram_socket</code> objects.
</div>
<pre><span id="VALdatagram_provider"><span class="keyword">val</span> datagram_provider</span> : <code class="type">?proxy:#<a href="Uq_engines.datagram_socket_provider-c.html">datagram_socket_provider</a> -><br>       <a href="Uq_engines.html#TYPEdatagram_type">datagram_type</a> -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -><br>       <a href="Uq_engines.wrapped_datagram_socket-c.html">wrapped_datagram_socket</a> <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine creates a datagram socket as demanded by the <code class="code">datagram_type</code>,
 optionally using <code class="code">proxy</code> for sending and receiving datagrams.
<p>

 The socket is unconnected.
<p>

 The socket is in non-blocking mode, and the close-on-exec flag is 
 set.<br>
</div>
<br>
<h1 id="1_MultiplexControllers">Multiplex Controllers</h1><br>
<pre><span id="TYPEmultiplex_controller"><span class="keyword">class type</span> <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a></span> = <code class="code">object</code> <a href="Uq_engines.multiplex_controller-c.html">..</a> <code class="code">end</code></pre><div class="info">
A <code class="code">multiplex_controller</code> is a quite low-level device to abstract
 bidirectional socket connections.
</div>
<pre><span id="EXCEPTIONMem_not_supported"><span class="keyword">exception</span> Mem_not_supported</span></pre>
<div class="info">
May be raised by multiplex controller methods <code class="code">start_mem_reading</code> and
      <code class="code">start_mem_writing</code> if these methods are not supported for the kind
      of file descriptor<br>
</div>
<pre><span id="VALcreate_multiplex_controller_for_connected_socket"><span class="keyword">val</span> create_multiplex_controller_for_connected_socket</span> : <code class="type">?close_inactive_descr:bool -><br>       ?preclose:(unit -> unit) -><br>       ?supports_half_open_connection:bool -><br>       ?timeout:float * exn -><br>       Unix.file_descr -><br>       <a href="Unixqueue.unix_event_system-c.html">Unixqueue.unix_event_system</a> -> <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a></code></pre><div class="info">
Creates a multiplex controller for a bidirectional socket (e.g.
 a TCP socket). It is essential that the socket is in connected state.
 This function also supports Win32 named pipes.
<p>

 Note that the file descriptor is not closed when the attached engines
 are terminated. One can call <code class="code">inactivate</code> manually to do that.
<p>

 <code class="code">close_inactive_descr</code>: Whether <code class="code">inactivate</code> closes the descriptor.
 True by default.
<p>

 <code class="code">preclose</code>: This function is called just before the descriptor is
 closed.
<p>

 <code class="code">supports_half_open_connection</code>: This implementation does not know
 how to find out whether the socket supports half-open connections.
 You can simply set this boolean because of this. Defaults to <code class="code">false</code>.
 You can set it to <code class="code">true</code> for TCP connections and for Unix-domain
 connections with stream semantics.
<p>

 <code class="code">timeout</code>: If set to <code class="code">(t, x)</code>, a general timeout of <code class="code">t</code> is set.
 When an operation has been started, and there is no I/O activity within
 <code class="code">t</code> seconds, neither by the started operation nor by another operation,
 the connection times out. In this case, the operation returns the
 exception <code class="code">x</code>.<br>
</div>
<pre><span id="TYPEdatagram_multiplex_controller"><span class="keyword">class type</span> <a href="Uq_engines.datagram_multiplex_controller-c.html">datagram_multiplex_controller</a></span> = <code class="code">object</code> <a href="Uq_engines.datagram_multiplex_controller-c.html">..</a> <code class="code">end</code></pre><div class="info">
Additional methods for unconnected datagram handling
</div>
<pre><span id="VALcreate_multiplex_controller_for_datagram_socket"><span class="keyword">val</span> create_multiplex_controller_for_datagram_socket</span> : <code class="type">?close_inactive_descr:bool -><br>       ?preclose:(unit -> unit) -><br>       ?timeout:float * exn -><br>       Unix.file_descr -><br>       <a href="Unixqueue.unix_event_system-c.html">Unixqueue.unix_event_system</a> -> <a href="Uq_engines.datagram_multiplex_controller-c.html">datagram_multiplex_controller</a></code></pre><div class="info">
Creates a multiplex controller for datagram sockets (e.g. UDP socket).
<p>

 Note that the file descriptor is not closed when the attached engines
 are terminated. One can call <code class="code">inactivate</code> manually to do that.
<p>

 <code class="code">close_inactive_descr</code>: Whether <code class="code">inactivate</code> closes the descriptor.
 True by default.
<p>

 <code class="code">preclose</code>: This function is called just before the descriptor is
 closed.
<p>

 <code class="code">timeout</code>: If set to <code class="code">(t, x)</code>, a general timeout of <code class="code">t</code> is set.
 When an operation has been started, and there is no I/O activity within
 <code class="code">t</code> seconds, neither by the started operation nor by another operation,
 the connection times out. In this case, the operation returns the
 exception <code class="code">x</code>.<br>
</div>
<pre><span id="TYPEonshutdown_out_spec"><span class="keyword">type</span> <code class="type"></code>onshutdown_out_spec</span> = <code class="type">[ `Action of<br>           <a href="Uq_engines.async_out_channel_engine-c.html">async_out_channel_engine</a> -><br>           <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a> -> unit <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> unit<br>       | `Ignore<br>       | `Initiate_shutdown ]</code> </pre>
<div class="info">
See class <code class="code">output_async_mplex</code> for explanations<br>
</div>

<pre><span id="TYPEonshutdown_in_spec"><span class="keyword">type</span> <code class="type"></code>onshutdown_in_spec</span> = <code class="type">[ `Action of<br>           <a href="Uq_engines.async_in_channel_engine-c.html">async_in_channel_engine</a> -><br>           <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a> -> unit <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> unit<br>       | `Ignore<br>       | `Initiate_shutdown ]</code> </pre>
<div class="info">
See class <code class="code">input_async_mplex</code> for explanations<br>
</div>

<pre><span name="TYPEoutput_async_mplex"><span class="keyword">class</span> <a href="Uq_engines.output_async_mplex-c.html">output_async_mplex</a></span> : <code class="type">?onclose:[ `Ignore | `Write_eof ] -> ?onshutdown:<a href="Uq_engines.html#TYPEonshutdown_out_spec">onshutdown_out_spec</a> -> ?buffer_size:int -> <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a> -> </code><code class="type"><a href="Uq_engines.async_out_channel_engine-c.html">async_out_channel_engine</a></code></pre><div class="info">
Creates an asynchronous output channel writing to the multiplex
 controller (see also <code class="code">output_async_descr</code> for the corresponding
 class writing to a single descriptor).
</div>
<pre><span name="TYPEinput_async_mplex"><span class="keyword">class</span> <a href="Uq_engines.input_async_mplex-c.html">input_async_mplex</a></span> : <code class="type">?onshutdown:<a href="Uq_engines.html#TYPEonshutdown_in_spec">onshutdown_in_spec</a> -> ?buffer_size:int -> <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a> -> </code><code class="type"><a href="Uq_engines.async_in_channel_engine-c.html">async_in_channel_engine</a></code></pre><div class="info">
Creates an asynchronous input channel reading from the multiplex
 controller.
</div>
<br>
<h1 id="1_Recursion">Recursion</h1><br>
<br>
When programming with engines, it is normal to use recursion for any
    kind of loops. For example, to read the lines from a file:
<p>

    <pre class="codepre"><code class="code">      open Uq_engines.Operators  (* for "&gt;&gt;" and "++" *)

      let fd = 
        Unix.openfile filename [Unix.O_RDONLY] 0 in
      let d = 
        `Buffer_in(Uq_io.create_in_buffer(`Polldescr(`Read_write,fd,esys))) in

      let rec read_lines acc =
        Uq_io.input_line_e d &gt;&gt;
          (function                       (* catch exception End_of_file *)
            | `Done line -&gt; `Done(Some line)
            | `Error End_of_file -&gt; `Done None
            | `Error error -&gt; `Error error
            | `Aborted -&gt; `Aborted
          ) ++
          (function
            | Some line -&gt;
                read_lines (line :: acc)
            | None -&gt;
                eps_e (`Done (List.rev acc)) esys
          ) in

      let e = read_lines []
    </code></pre>
<p>

    There is generally the question whether this style leads to stack
    overflows. This depends on the mechanisms that come into play:
<p>
<ul>
<li>The engine mechanism passing control from one engine to the next is
      not tail-recursive, and thus the stack can overflow when the
      recursion becomes too deep</li>
<li>The event queue mechanism, however, does not have this problem.
      Control falls automatically back to the event queue whenever I/O
      needs to be done.</li>
</ul>

    In this example, this means that only the engine mechanism is used
    as long as the data is read from the buffer. When the buffer needs
    to be refilled, however, control is passed back to the event queue
    (so the stack is cleaned), and the continuation of the execution
    is only managed via closures (which only allocate memory on the
    heap, not on the stack). Usually, this is a good compromise: The
    engine mechnism is a lot faster, but I/O is an indicator for using
    the better but slower technique.
<p>

    Also note another difference: The event queue mechanism allows that
    other asynchronous code attached to the same event queue may run
    (control maybe yielded to unrelated execution contexts). The
    pure engine mechanism does not allow that. This may be handy when
    exclusive access to variables is needed. (But be careful here -
    this is very sensitive to minimal changes of the implementation.)
<p>

    Certain engines enforce using the event queue mechanisms although they
    are unrelated to I/O. Especially <a href="Uq_engines.html#VALdelay_engine"><code class="code">Uq_engines.delay_engine</code></a> is
    useful here: A "delay" of 0 seconds is already sufficient to
    go back to the event queue. If recursions sometimes lead to
    stack overflows the solution is to include such a zero delay
    before doing the self call.<br>
<br>
<h1 id="1_MoreEngines">More Engines</h1><br>
<br>
Pointers to other modules related to engines:
<p>
<ul>
<li>RPC clients: The function <a href="Rpc_proxy.ManagedClient.html#VALrpc_engine"><code class="code">Rpc_proxy.ManagedClient.rpc_engine</code></a> allows
    to call an RPC via an engine. When the call is done, the engine transitions
    to <code class="code">`Done r</code>, and <code class="code">r</code> is the result of the remote call.</li>
<li>Subprograms: The class <a href="Shell_uq.call_engine-c.html"><code class="code">Shell_uq.call_engine</code></a> allows to start an
    external program, and to monitor it via an engine.</li>
</ul>
<br>
<br>
<h1 id="1_Debugging">Debugging</h1><br>
<pre><span class="keyword">module</span> <a href="Uq_engines.Debug.html">Debug</a>: <code class="code">sig</code> <a href="Uq_engines.Debug.html">..</a> <code class="code">end</code></pre></body></html>