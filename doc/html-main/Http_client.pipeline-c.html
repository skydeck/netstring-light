<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Http_client.digest_auth_method-c.html">
<link rel="Up" href="Http_client.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Uq_mt" rel="Chapter" href="Uq_mt.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Equeue_howto" rel="Chapter" href="Equeue_howto.html">
<link title="Uq_ssl" rel="Chapter" href="Uq_ssl.html">
<link title="Https_client" rel="Chapter" href="Https_client.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Http_client_conncache" rel="Chapter" href="Http_client_conncache.html">
<link title="Http_client" rel="Chapter" href="Http_client.html">
<link title="Telnet_client" rel="Chapter" href="Telnet_client.html">
<link title="Ftp_data_endpoint" rel="Chapter" href="Ftp_data_endpoint.html">
<link title="Ftp_client" rel="Chapter" href="Ftp_client.html">
<link title="Http_fs" rel="Chapter" href="Http_fs.html">
<link title="Ftp_fs" rel="Chapter" href="Ftp_fs.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgssapi" rel="Chapter" href="Netgssapi.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Mimestring" rel="Chapter" href="Mimestring.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Rtypes" rel="Chapter" href="Rtypes.html">
<link title="Xdr_mstring" rel="Chapter" href="Xdr_mstring.html">
<link title="Xdr" rel="Chapter" href="Xdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netunichar" rel="Chapter" href="Netunichar.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netsys_sem" rel="Chapter" href="Netsys_sem.html">
<link title="Netsys_pmanage" rel="Chapter" href="Netsys_pmanage.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Rpc_auth_dh" rel="Chapter" href="Rpc_auth_dh.html">
<link title="Rpc_key_service" rel="Chapter" href="Rpc_key_service.html">
<link title="Rpc_time" rel="Chapter" href="Rpc_time.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Rpc_ssl" rel="Chapter" href="Rpc_ssl.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html"><title>Ocamlnet 3 Reference Manual : Http_client.pipeline</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Http_client.digest_auth_method-c.html" title="Http_client.digest_auth_method">Previous</a>
&nbsp;<a class="up" href="Http_client.html" title="Http_client">Up</a>
&nbsp;</div>
<h1>Class <a href="type_Http_client.pipeline.html">Http_client.pipeline</a></h1>
<pre><span name="TYPEpipeline"><span class="keyword">class</span> pipeline</span> : <code class="type"></code><code class="code">object</code> <a href="Http_client.pipeline-c.html">..</a> <code class="code">end</code></pre><div class="info">
A pipeline is a queue of HTTP calls to perform<br>
</div>
<hr width="100%">
<h2 id="2_A">A </h2><code class="code">pipeline</code> object is a FIFO queue of HTTP calls. It is called
 "pipeline" because it is processed asynchronously: Requests may be
 sent to the HTTP server independently of whether responses of the
 previous requests already arrived or not.
<p>

 Furthermore, a <code class="code">pipeline</code> object may keep connections to several
 servers at once. (More exactly, it has a FIFO queue for every
 server it is connected with.)
<p>

 The <code class="code">pipeline</code> object keeps track what is happening, so you need
 not to care about the details of communications. The API is
 simple: Create a <code class="code">pipeline</code> object, do some setup (add authentication
 methods; configure the proxy to use), add the requests, and 
 <code class="code">run</code> the pipeline. The rest is done automatically. To get the results,
 you can either memorize the requests you wanted to know yourself
 and ask every request object about the reply of the server; or
 you can specify that a callback function should be called once
 the request is processed (with positive or negative result).
 It is possible to add further requests to the pipeline from within
 these callback functions.
<p>

 If you want to have several pipelines, or some cooperation with
 other network services, you may specify a <code class="code">Unixqueue.event_system</code>.
 For example, to have two pipelines working concurrently:
<p>

 <pre class="codepre"><code class="code"> let ues = Unixqueue.create_unix_event_system() in
 let p1 = new pipeline in
 let p2 = new pipeline in
 p1 # set_event_system ues;
 p2 # set_event_system ues;
 Unixqueue.run ues             (* run p1 and p2 in parallel *)
 </code></pre>
<p>

 This works not only with pipelines, but with every network client
 or server which is compatible with the <code class="code">Unixqueue</code> design.<pre><span id="METHODevent_system"><span class="keyword">method</span> event_system</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a></code></pre><div class="info">
Returns the event system<br>
</div>
<pre><span id="METHODset_event_system"><span class="keyword">method</span> set_event_system</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> unit</code></pre><div class="info">
Sets the event system. Must be called before the first call
 is added<br>
</div>
<pre><span id="METHODconnection_cache"><span class="keyword">method</span> connection_cache</span> : <code class="type"><a href="Http_client.html#TYPEconnection_cache">connection_cache</a></code></pre><div class="info">
The current connection cache. By default, a private
 restrictive cache is used.<br>
</div>
<pre><span id="METHODset_connection_cache"><span class="keyword">method</span> set_connection_cache</span> : <code class="type"><a href="Http_client.html#TYPEconnection_cache">connection_cache</a> -> unit</code></pre><div class="info">
Set the connection cache. This must happen before the first
 call is added.<br>
</div>
<pre><span id="METHODadd_authentication_method"><span class="keyword">method</span> add_authentication_method</span> : <code class="type"><a href="Http_client.basic_auth_method-c.html">basic_auth_method</a> -> unit</code></pre><div class="info">
adds an old-style authentication method<br>
</div>
<pre><span id="METHODadd_auth_handler"><span class="keyword">method</span> add_auth_handler</span> : <code class="type"><a href="Http_client.auth_handler-c.html">auth_handler</a> -> unit</code></pre><div class="info">
adds a new-style authentication handler<br>
</div>
<pre><span id="METHODset_proxy"><span class="keyword">method</span> set_proxy</span> : <code class="type">string -> int -> unit</code></pre><div class="info">
<code class="code">set_proxy name port</code>:
 sets that an HTTP proxy <code class="code">name</code> listening on <code class="code">port</code> is to be used<br>
</div>
<pre><span id="METHODset_proxy_auth"><span class="keyword">method</span> set_proxy_auth</span> : <code class="type">string -> string -> unit</code></pre><div class="info">
sets user and password for the proxy. Works for both "digest"
	    and "basic" mechanisms. Any realm is acceptable.<br>
</div>
<pre><span id="METHODavoid_proxy_for"><span class="keyword">method</span> avoid_proxy_for</span> : <code class="type">string list -> unit</code></pre><div class="info">
sets a list of host names or domain suffixes for which no proxy
 should be used. 
 e.g. <code class="code"> "localhost"; ".our.net" </code><br>
</div>
<pre><span id="METHODset_proxy_from_environment"><span class="keyword">method</span> set_proxy_from_environment</span> : <code class="type">unit -> unit</code></pre><div class="info">
Inspect the environment variables <code class="code">http_proxy</code> and <code class="code">no_proxy</code>
 and set the proxy options from them.<br>
</div>
<pre><span id="METHODset_socks5_proxy"><span class="keyword">method</span> set_socks5_proxy</span> : <code class="type">string -> int -> unit</code></pre><div class="info">
Sets that a SOCKS version 5 proxy is used at this host and port.
	  There is no authentication. The <code class="code">avoid_proxy_for</code> setting is
	  honoured.<br>
</div>
<pre><span id="METHODconfigure_transport"><span class="keyword">method</span> configure_transport</span> : <code class="type"><a href="Http_client.html#TYPEchannel_binding_id">channel_binding_id</a> -> <a href="Http_client.transport_channel_type-c.html">transport_channel_type</a> -> unit</code></pre><div class="info">
<code class="code">configure_transport id transport</code>: Configures that messages with
	   channel binding ID <code class="code">id</code> are exchanged on <code class="code">transport</code>.
<p>

	   By default, there is only a configuration for
	   <a href="Http_client.html#VALhttp_cb_id"><code class="code">Http_client.http_cb_id</code></a>, i.e. for normal unencrypted channels.<br>
</div>
<pre><span id="METHODset_transport_proxy"><span class="keyword">method</span> set_transport_proxy</span> : <code class="type"><a href="Http_client.html#TYPEchannel_binding_id">channel_binding_id</a> -><br>       string -> int -> (string * string) option -> <a href="Http_client.html#TYPEproxy_type">proxy_type</a> -> unit</code></pre><div class="info">
<code class="code">set_transport_proxy id host port auth ptype</code>: Sets a special
	  proxy for the transport identified by <code class="code">id</code>. This overrides
	  <code class="code">set_proxy</code>, <code class="code">set_proxy_auth</code>, and <code class="code">set_socks5_proxy</code> for the
	  given transport.<br>
</div>
<pre><span id="METHODset_transport_proxy_from_environment"><span class="keyword">method</span> set_transport_proxy_from_environment</span> : <code class="type">(string * <a href="Http_client.html#TYPEchannel_binding_id">channel_binding_id</a>) list -> unit</code></pre><div class="info">
Like <code class="code">set_proxy_from_environment</code>, this method inspects environment
	  variables and configures the proxy settings. This function, however,
	  is more flexible, and can use different environment variables for
	  different transports.
<p>

	  The argument list has pairs <code class="code">(var_name, id)</code> meaning that the
	  environment variable <code class="code">var_name</code> configures the proxy for <code class="code">id</code>.
	  For instance, 
	  <pre class="codepre"><code class="code"> [("http_proxy", http_cb_id); ("https_proxy", https_cb_id)] </code></pre>
	  means that these two variables are used for the respective
	  transports.
<p>

	  The variable <code class="code">"no_proxy"</code> is interpreted anyway.<br>
</div>
<pre><span id="METHODreset"><span class="keyword">method</span> reset</span> : <code class="type">unit -> unit</code></pre><div class="info">
Empties the pipeline and inactivates any open connection.
 The currently active operation is interrupted, and every request
 with response is set to <code class="code">No_reply</code> (i.e. you get the exception
 <code class="code">No_reply</code> if you try to access the response).
 If there are callbacks for these requests, the callback
 functions are invoked.
 The queues of open requests and replies are cleared. All
 connections to all servers are inactivated.
<p>

 Inactivation means that open connections are given back
 to the connection cache for further reuse if the state
 of the connection allows this; otherwise the connections are
 closed.<br>
</div>
<pre><span id="METHODadd"><span class="keyword">method</span> add</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> -> unit</code></pre><div class="info">
Adds the call to the end of the pipeline. 
 One must not add calls that have already been served.<br>
</div>
<pre><span id="METHODadd_with_callback"><span class="keyword">method</span> add_with_callback</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> -> (<a href="Http_client.http_call-c.html">http_call</a> -> unit) -> unit</code></pre><div class="info">
Adds the call to the end of the pipeline.
<p>

 After the call has been processed, the callback function
 is called. This function is called for every call that
 leaves the pipeline, it does not matter whether processing
 was successful or not. Invoke <code class="code">status</code> on the message
 to get what happened; either some status information from the
 server is available (perhaps OK status), or an exception is
 indicated.<br>
</div>
<pre><span id="METHODadd_e"><span class="keyword">method</span> add_e</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> -> <a href="Http_client.http_call-c.html">http_call</a> <a href="Uq_engines.engine-c.html">Uq_engines.engine</a></code></pre><div class="info">
The same as engine: The call <code class="code">c</code> is added to the pipeline, and
	  when it is processed, the returned engine transitions to the
	  state <code class="code">`Done c</code>.<br>
</div>
<pre><span id="METHODproxy_type"><span class="keyword">method</span> proxy_type</span> : <code class="type">string -> <a href="Http_client.html#TYPEproxy_type">proxy_type</a> option</code></pre><div class="info">
<code class="code">proxy_type url</code> returns <code class="code">Some pt</code> if a proxy would be used for this
	  <code class="code">url</code>, and <code class="code">None</code> if a direct connection would be made.<br>
</div>
<pre><span id="METHODproxy_type_of_call"><span class="keyword">method</span> proxy_type_of_call</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> -> <a href="Http_client.html#TYPEproxy_type">proxy_type</a> option</code></pre><div class="info">
Same for an already created call object<br>
</div>
<pre><span id="METHODchannel_binding"><span class="keyword">method</span> channel_binding</span> : <code class="type"><a href="Http_client.http_call-c.html">http_call</a> -> <a href="Http_client.html#TYPEchannel_binding_id">channel_binding_id</a></code></pre><div class="info">
Reports the current channel binding of this call<br>
</div>
<pre><span id="METHODrun"><span class="keyword">method</span> run</span> : <code class="type">unit -> unit</code></pre><div class="info">
Runs through the requests in the pipeline. If a request can be
 fulfilled, i.e. the server sends a response, the state of the
 request is set and the request is removed from the pipeline.
 If a request cannot be fulfilled (no response, bad response, 
 network error), the exception is stored in the <code class="code">http_call</code>
 object and will be raised once the state of the object is
 queried.
<p>

 Under certain conditions (serious network errors) <code class="code">run</code> does
 not catch the exception; it simply cleans its own state up
 (aborting the errorneous network connection). In this case,
 simply invoke <code class="code">run</code> again to continue.
 <code class="code">run</code> terminates normally if the pipeline becomes empty.
<p>

 The engine handles the following HTTP return codes itself:<ul>
<li>100: This is an intermediate return code </li>
<li>301: The redirection is followed if configured</li>
<li>302: The redirection is followed if configured</li>
<li>401: Content server authentication</li>
<li>407: Proxy server authentication</li>
</ul>

 All other return codes remain uninterpreted, it is up to the
 caller of this function to react on them.
<br>
</div>
<pre><span id="METHODget_options"><span class="keyword">method</span> get_options</span> : <code class="type"><a href="Http_client.html#TYPEhttp_options">http_options</a></code></pre><pre><span id="METHODset_options"><span class="keyword">method</span> set_options</span> : <code class="type"><a href="Http_client.html#TYPEhttp_options">http_options</a> -> unit</code></pre><div class="info">
Get/Set the available options for the HTTP engine. 
 The new options will take into effect immediately.<br>
</div>
<pre><span id="METHODnumber_of_open_messages"><span class="keyword">method</span> number_of_open_messages</span> : <code class="type">int</code></pre><div class="info">
Returns the number of messages which are still in the pipeline.<br>
</div>
<pre><span id="METHODnumber_of_open_connections"><span class="keyword">method</span> number_of_open_connections</span> : <code class="type">int</code></pre><div class="info">
Returns the number of connections which are open at the same time
 and currently being used by this object (i.e. connections 
 returned to the cache do not count)<br>
</div>
<pre><span id="METHODconnections"><span class="keyword">method</span> connections</span> : <code class="type">(string * int * int) list</code></pre><div class="info">
Reports which connections exist: <code class="code"> (host, port, queue_length) </code><br>
</div>
<pre><span id="METHODcnt_new_connections"><span class="keyword">method</span> cnt_new_connections</span> : <code class="type">int</code></pre><div class="info">
Counts new connections (or better: attempts to establish connections)<br>
</div>
<pre><span id="METHODcnt_timed_out_connections"><span class="keyword">method</span> cnt_timed_out_connections</span> : <code class="type">int</code></pre><div class="info">
Counts connections given up because of timeouts<br>
</div>
<pre><span id="METHODcnt_crashed_connections"><span class="keyword">method</span> cnt_crashed_connections</span> : <code class="type">int</code></pre><div class="info">
Counts connections with network or protocol errors<br>
</div>
<pre><span id="METHODcnt_server_eof_connections"><span class="keyword">method</span> cnt_server_eof_connections</span> : <code class="type">int</code></pre><div class="info">
Counts connections the server terminated with EOF<br>
</div>
<pre><span id="METHODcnt_successful_connections"><span class="keyword">method</span> cnt_successful_connections</span> : <code class="type">int</code></pre><div class="info">
Counts connections closed because pipelines become empty<br>
</div>
<pre><span id="METHODcnt_failed_connections"><span class="keyword">method</span> cnt_failed_connections</span> : <code class="type">int</code></pre><div class="info">
Counts totally failed connections (no more reconnects allowed)<br>
</div>
<pre><span id="METHODreset_counters"><span class="keyword">method</span> reset_counters</span> : <code class="type">unit -> unit</code></pre><h2 id="2_Notesoncounters">Notes on counters:</h2>
<p>
<ul>
<li><code class="code">cnt_new_connections</code>: Is increased when a new connection attempt
   is started (that may fail or timeout in the future). Reconnects
   do not count.</li>
<li><code class="code">cnt_timed_out_connections</code>: Is increased whenever an established
   connection times out. Usually, it is immediately reconnected.</li>
<li><code class="code">cnt_crashed_connections</code>: Is increased whenever an established
   connection crashes. Usually, it is immediately reconnected.</li>
<li><code class="code">cnt_failed_connections</code>: Is increased when a timed out or
   crashed connection exceeds the maximum number of errors, and it is
   not tried to reconnect.</li>
<li><code class="code">cnt_successful_connections</code>: Is increased when all HTTP calls
   have been replied.</li>
</ul>

 When the client has done all of its jobs, we have
<p>

 <pre class="codepre"><code class="code"> cnt_new_connections = cnt_failed_connections + cnt_successful_connections </code></pre>
</body></html>